Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    BAD_ID_WITH_DOLLAR
    INVALID

Grammar

Rule 0     S' -> program
Rule 1     program -> declaration_list
Rule 2     declaration_list -> declaration_list declaration
Rule 3     declaration_list -> declaration
Rule 4     declaration -> var_decl
Rule 5     declaration -> func_decl
Rule 6     var_decl -> type ID SEMI
Rule 7     var_decl -> type ID LBRACKET INT_LITERAL RBRACKET SEMI
Rule 8     type -> INT
Rule 9     type -> FLOAT
Rule 10    type -> BOOL
Rule 11    type -> CHAR
Rule 12    type -> STRING
Rule 13    func_decl -> FUNC ID LPAREN param_list_opt RPAREN block
Rule 14    param_list_opt -> param_list
Rule 15    param_list_opt -> empty
Rule 16    param_list -> param_list COMMA param
Rule 17    param_list -> param
Rule 18    param -> type ID
Rule 19    block -> LBRACE statement_list RBRACE
Rule 20    statement_list -> statement_list statement
Rule 21    statement_list -> empty
Rule 22    statement -> assignment SEMI
Rule 23    statement -> var_decl
Rule 24    statement -> func_call SEMI
Rule 25    statement -> if_stmt
Rule 26    statement -> while_stmt
Rule 27    statement -> for_stmt
Rule 28    statement -> io_stmt SEMI
Rule 29    statement -> return_stmt SEMI
Rule 30    statement -> break_stmt SEMI
Rule 31    statement -> continue_stmt SEMI
Rule 32    statement -> block
Rule 33    assignment -> location ASSIGN expr
Rule 34    location -> ID
Rule 35    location -> ID LBRACKET expr RBRACKET
Rule 36    if_stmt -> IF LPAREN expr RPAREN block elif_part else_part_opt
Rule 37    elif_part -> ELIF LPAREN expr RPAREN block elif_part
Rule 38    elif_part -> empty
Rule 39    else_part_opt -> ELSE block
Rule 40    else_part_opt -> empty
Rule 41    while_stmt -> WHILE LPAREN expr RPAREN block
Rule 42    for_stmt -> FOR LPAREN assignment SEMI expr SEMI assignment RPAREN block
Rule 43    io_stmt -> PRINT LPAREN expr RPAREN
Rule 44    io_stmt -> INPUT LPAREN ID RPAREN
Rule 45    return_stmt -> RETURN expr_opt
Rule 46    expr_opt -> expr
Rule 47    expr_opt -> empty
Rule 48    break_stmt -> BREAK
Rule 49    continue_stmt -> CONTINUE
Rule 50    expr -> expr PLUS expr
Rule 51    expr -> expr MINUS expr
Rule 52    expr -> expr TIMES expr
Rule 53    expr -> expr DIVIDE expr
Rule 54    expr -> expr MOD expr
Rule 55    expr -> expr LT expr
Rule 56    expr -> expr GT expr
Rule 57    expr -> expr LE expr
Rule 58    expr -> expr GE expr
Rule 59    expr -> expr EQ expr
Rule 60    expr -> expr NE expr
Rule 61    expr -> expr AND expr
Rule 62    expr -> expr OR expr
Rule 63    expr -> MINUS expr
Rule 64    expr -> NOT expr
Rule 65    expr -> LPAREN expr RPAREN
Rule 66    expr -> literal
Rule 67    expr -> location
Rule 68    expr -> func_call
Rule 69    func_call -> ID LPAREN arg_list_opt RPAREN
Rule 70    arg_list_opt -> arg_list
Rule 71    arg_list_opt -> empty
Rule 72    arg_list -> arg_list COMMA expr
Rule 73    arg_list -> expr
Rule 74    literal -> INT_LITERAL
Rule 75    literal -> FLOAT_LITERAL
Rule 76    literal -> CHAR_LITERAL
Rule 77    literal -> STRING_LITERAL
Rule 78    literal -> TRUE
Rule 79    literal -> FALSE
Rule 80    empty -> <empty>

Terminals, with rules where they appear

AND                  : 61
ASSIGN               : 33
BAD_ID_WITH_DOLLAR   : 
BOOL                 : 10
BREAK                : 48
CHAR                 : 11
CHAR_LITERAL         : 76
COMMA                : 16 72
CONTINUE             : 49
DIVIDE               : 53
ELIF                 : 37
ELSE                 : 39
EQ                   : 59
FALSE                : 79
FLOAT                : 9
FLOAT_LITERAL        : 75
FOR                  : 42
FUNC                 : 13
GE                   : 58
GT                   : 56
ID                   : 6 7 13 18 34 35 44 69
IF                   : 36
INPUT                : 44
INT                  : 8
INT_LITERAL          : 7 74
INVALID              : 
LBRACE               : 19
LBRACKET             : 7 35
LE                   : 57
LPAREN               : 13 36 37 41 42 43 44 65 69
LT                   : 55
MINUS                : 51 63
MOD                  : 54
NE                   : 60
NOT                  : 64
OR                   : 62
PLUS                 : 50
PRINT                : 43
RBRACE               : 19
RBRACKET             : 7 35
RETURN               : 45
RPAREN               : 13 36 37 41 42 43 44 65 69
SEMI                 : 6 7 22 24 28 29 30 31 42 42
STRING               : 12
STRING_LITERAL       : 77
TIMES                : 52
TRUE                 : 78
WHILE                : 41
error                : 

Nonterminals, with rules where they appear

arg_list             : 70 72
arg_list_opt         : 69
assignment           : 22 42 42
block                : 13 32 36 37 39 41 42
break_stmt           : 30
continue_stmt        : 31
declaration          : 2 3
declaration_list     : 1 2
elif_part            : 36 37
else_part_opt        : 36
empty                : 15 21 38 40 47 71
expr                 : 33 35 36 37 41 42 43 46 50 50 51 51 52 52 53 53 54 54 55 55 56 56 57 57 58 58 59 59 60 60 61 61 62 62 63 64 65 72 73
expr_opt             : 45
for_stmt             : 27
func_call            : 24 68
func_decl            : 5
if_stmt              : 25
io_stmt              : 28
literal              : 66
location             : 33 67
param                : 16 17
param_list           : 14 16
param_list_opt       : 13
program              : 0
return_stmt          : 29
statement            : 20
statement_list       : 19 20
type                 : 6 7 18
var_decl             : 4 23
while_stmt           : 26

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . declaration_list
    (2) declaration_list -> . declaration_list declaration
    (3) declaration_list -> . declaration
    (4) declaration -> . var_decl
    (5) declaration -> . func_decl
    (6) var_decl -> . type ID SEMI
    (7) var_decl -> . type ID LBRACKET INT_LITERAL RBRACKET SEMI
    (13) func_decl -> . FUNC ID LPAREN param_list_opt RPAREN block
    (8) type -> . INT
    (9) type -> . FLOAT
    (10) type -> . BOOL
    (11) type -> . CHAR
    (12) type -> . STRING

    FUNC            shift and go to state 7
    INT             shift and go to state 8
    FLOAT           shift and go to state 9
    BOOL            shift and go to state 10
    CHAR            shift and go to state 11
    STRING          shift and go to state 12

    program                        shift and go to state 1
    declaration_list               shift and go to state 2
    declaration                    shift and go to state 3
    var_decl                       shift and go to state 4
    func_decl                      shift and go to state 5
    type                           shift and go to state 6

state 1

    (0) S' -> program .



state 2

    (1) program -> declaration_list .
    (2) declaration_list -> declaration_list . declaration
    (4) declaration -> . var_decl
    (5) declaration -> . func_decl
    (6) var_decl -> . type ID SEMI
    (7) var_decl -> . type ID LBRACKET INT_LITERAL RBRACKET SEMI
    (13) func_decl -> . FUNC ID LPAREN param_list_opt RPAREN block
    (8) type -> . INT
    (9) type -> . FLOAT
    (10) type -> . BOOL
    (11) type -> . CHAR
    (12) type -> . STRING

    $end            reduce using rule 1 (program -> declaration_list .)
    FUNC            shift and go to state 7
    INT             shift and go to state 8
    FLOAT           shift and go to state 9
    BOOL            shift and go to state 10
    CHAR            shift and go to state 11
    STRING          shift and go to state 12

    declaration                    shift and go to state 13
    var_decl                       shift and go to state 4
    func_decl                      shift and go to state 5
    type                           shift and go to state 6

state 3

    (3) declaration_list -> declaration .

    FUNC            reduce using rule 3 (declaration_list -> declaration .)
    INT             reduce using rule 3 (declaration_list -> declaration .)
    FLOAT           reduce using rule 3 (declaration_list -> declaration .)
    BOOL            reduce using rule 3 (declaration_list -> declaration .)
    CHAR            reduce using rule 3 (declaration_list -> declaration .)
    STRING          reduce using rule 3 (declaration_list -> declaration .)
    $end            reduce using rule 3 (declaration_list -> declaration .)


state 4

    (4) declaration -> var_decl .

    FUNC            reduce using rule 4 (declaration -> var_decl .)
    INT             reduce using rule 4 (declaration -> var_decl .)
    FLOAT           reduce using rule 4 (declaration -> var_decl .)
    BOOL            reduce using rule 4 (declaration -> var_decl .)
    CHAR            reduce using rule 4 (declaration -> var_decl .)
    STRING          reduce using rule 4 (declaration -> var_decl .)
    $end            reduce using rule 4 (declaration -> var_decl .)


state 5

    (5) declaration -> func_decl .

    FUNC            reduce using rule 5 (declaration -> func_decl .)
    INT             reduce using rule 5 (declaration -> func_decl .)
    FLOAT           reduce using rule 5 (declaration -> func_decl .)
    BOOL            reduce using rule 5 (declaration -> func_decl .)
    CHAR            reduce using rule 5 (declaration -> func_decl .)
    STRING          reduce using rule 5 (declaration -> func_decl .)
    $end            reduce using rule 5 (declaration -> func_decl .)


state 6

    (6) var_decl -> type . ID SEMI
    (7) var_decl -> type . ID LBRACKET INT_LITERAL RBRACKET SEMI

    ID              shift and go to state 14


state 7

    (13) func_decl -> FUNC . ID LPAREN param_list_opt RPAREN block

    ID              shift and go to state 15


state 8

    (8) type -> INT .

    ID              reduce using rule 8 (type -> INT .)


state 9

    (9) type -> FLOAT .

    ID              reduce using rule 9 (type -> FLOAT .)


state 10

    (10) type -> BOOL .

    ID              reduce using rule 10 (type -> BOOL .)


state 11

    (11) type -> CHAR .

    ID              reduce using rule 11 (type -> CHAR .)


state 12

    (12) type -> STRING .

    ID              reduce using rule 12 (type -> STRING .)


state 13

    (2) declaration_list -> declaration_list declaration .

    FUNC            reduce using rule 2 (declaration_list -> declaration_list declaration .)
    INT             reduce using rule 2 (declaration_list -> declaration_list declaration .)
    FLOAT           reduce using rule 2 (declaration_list -> declaration_list declaration .)
    BOOL            reduce using rule 2 (declaration_list -> declaration_list declaration .)
    CHAR            reduce using rule 2 (declaration_list -> declaration_list declaration .)
    STRING          reduce using rule 2 (declaration_list -> declaration_list declaration .)
    $end            reduce using rule 2 (declaration_list -> declaration_list declaration .)


state 14

    (6) var_decl -> type ID . SEMI
    (7) var_decl -> type ID . LBRACKET INT_LITERAL RBRACKET SEMI

    SEMI            shift and go to state 16
    LBRACKET        shift and go to state 17


state 15

    (13) func_decl -> FUNC ID . LPAREN param_list_opt RPAREN block

    LPAREN          shift and go to state 18


state 16

    (6) var_decl -> type ID SEMI .

    FUNC            reduce using rule 6 (var_decl -> type ID SEMI .)
    INT             reduce using rule 6 (var_decl -> type ID SEMI .)
    FLOAT           reduce using rule 6 (var_decl -> type ID SEMI .)
    BOOL            reduce using rule 6 (var_decl -> type ID SEMI .)
    CHAR            reduce using rule 6 (var_decl -> type ID SEMI .)
    STRING          reduce using rule 6 (var_decl -> type ID SEMI .)
    $end            reduce using rule 6 (var_decl -> type ID SEMI .)
    RBRACE          reduce using rule 6 (var_decl -> type ID SEMI .)
    ID              reduce using rule 6 (var_decl -> type ID SEMI .)
    IF              reduce using rule 6 (var_decl -> type ID SEMI .)
    WHILE           reduce using rule 6 (var_decl -> type ID SEMI .)
    FOR             reduce using rule 6 (var_decl -> type ID SEMI .)
    PRINT           reduce using rule 6 (var_decl -> type ID SEMI .)
    INPUT           reduce using rule 6 (var_decl -> type ID SEMI .)
    RETURN          reduce using rule 6 (var_decl -> type ID SEMI .)
    BREAK           reduce using rule 6 (var_decl -> type ID SEMI .)
    CONTINUE        reduce using rule 6 (var_decl -> type ID SEMI .)
    LBRACE          reduce using rule 6 (var_decl -> type ID SEMI .)


state 17

    (7) var_decl -> type ID LBRACKET . INT_LITERAL RBRACKET SEMI

    INT_LITERAL     shift and go to state 19


state 18

    (13) func_decl -> FUNC ID LPAREN . param_list_opt RPAREN block
    (14) param_list_opt -> . param_list
    (15) param_list_opt -> . empty
    (16) param_list -> . param_list COMMA param
    (17) param_list -> . param
    (80) empty -> .
    (18) param -> . type ID
    (8) type -> . INT
    (9) type -> . FLOAT
    (10) type -> . BOOL
    (11) type -> . CHAR
    (12) type -> . STRING

    RPAREN          reduce using rule 80 (empty -> .)
    INT             shift and go to state 8
    FLOAT           shift and go to state 9
    BOOL            shift and go to state 10
    CHAR            shift and go to state 11
    STRING          shift and go to state 12

    param_list_opt                 shift and go to state 20
    param_list                     shift and go to state 21
    empty                          shift and go to state 22
    param                          shift and go to state 23
    type                           shift and go to state 24

state 19

    (7) var_decl -> type ID LBRACKET INT_LITERAL . RBRACKET SEMI

    RBRACKET        shift and go to state 25


state 20

    (13) func_decl -> FUNC ID LPAREN param_list_opt . RPAREN block

    RPAREN          shift and go to state 26


state 21

    (14) param_list_opt -> param_list .
    (16) param_list -> param_list . COMMA param

    RPAREN          reduce using rule 14 (param_list_opt -> param_list .)
    COMMA           shift and go to state 27


state 22

    (15) param_list_opt -> empty .

    RPAREN          reduce using rule 15 (param_list_opt -> empty .)


state 23

    (17) param_list -> param .

    COMMA           reduce using rule 17 (param_list -> param .)
    RPAREN          reduce using rule 17 (param_list -> param .)


state 24

    (18) param -> type . ID

    ID              shift and go to state 28


state 25

    (7) var_decl -> type ID LBRACKET INT_LITERAL RBRACKET . SEMI

    SEMI            shift and go to state 29


state 26

    (13) func_decl -> FUNC ID LPAREN param_list_opt RPAREN . block
    (19) block -> . LBRACE statement_list RBRACE

    LBRACE          shift and go to state 31

    block                          shift and go to state 30

state 27

    (16) param_list -> param_list COMMA . param
    (18) param -> . type ID
    (8) type -> . INT
    (9) type -> . FLOAT
    (10) type -> . BOOL
    (11) type -> . CHAR
    (12) type -> . STRING

    INT             shift and go to state 8
    FLOAT           shift and go to state 9
    BOOL            shift and go to state 10
    CHAR            shift and go to state 11
    STRING          shift and go to state 12

    param                          shift and go to state 32
    type                           shift and go to state 24

state 28

    (18) param -> type ID .

    COMMA           reduce using rule 18 (param -> type ID .)
    RPAREN          reduce using rule 18 (param -> type ID .)


state 29

    (7) var_decl -> type ID LBRACKET INT_LITERAL RBRACKET SEMI .

    FUNC            reduce using rule 7 (var_decl -> type ID LBRACKET INT_LITERAL RBRACKET SEMI .)
    INT             reduce using rule 7 (var_decl -> type ID LBRACKET INT_LITERAL RBRACKET SEMI .)
    FLOAT           reduce using rule 7 (var_decl -> type ID LBRACKET INT_LITERAL RBRACKET SEMI .)
    BOOL            reduce using rule 7 (var_decl -> type ID LBRACKET INT_LITERAL RBRACKET SEMI .)
    CHAR            reduce using rule 7 (var_decl -> type ID LBRACKET INT_LITERAL RBRACKET SEMI .)
    STRING          reduce using rule 7 (var_decl -> type ID LBRACKET INT_LITERAL RBRACKET SEMI .)
    $end            reduce using rule 7 (var_decl -> type ID LBRACKET INT_LITERAL RBRACKET SEMI .)
    RBRACE          reduce using rule 7 (var_decl -> type ID LBRACKET INT_LITERAL RBRACKET SEMI .)
    ID              reduce using rule 7 (var_decl -> type ID LBRACKET INT_LITERAL RBRACKET SEMI .)
    IF              reduce using rule 7 (var_decl -> type ID LBRACKET INT_LITERAL RBRACKET SEMI .)
    WHILE           reduce using rule 7 (var_decl -> type ID LBRACKET INT_LITERAL RBRACKET SEMI .)
    FOR             reduce using rule 7 (var_decl -> type ID LBRACKET INT_LITERAL RBRACKET SEMI .)
    PRINT           reduce using rule 7 (var_decl -> type ID LBRACKET INT_LITERAL RBRACKET SEMI .)
    INPUT           reduce using rule 7 (var_decl -> type ID LBRACKET INT_LITERAL RBRACKET SEMI .)
    RETURN          reduce using rule 7 (var_decl -> type ID LBRACKET INT_LITERAL RBRACKET SEMI .)
    BREAK           reduce using rule 7 (var_decl -> type ID LBRACKET INT_LITERAL RBRACKET SEMI .)
    CONTINUE        reduce using rule 7 (var_decl -> type ID LBRACKET INT_LITERAL RBRACKET SEMI .)
    LBRACE          reduce using rule 7 (var_decl -> type ID LBRACKET INT_LITERAL RBRACKET SEMI .)


state 30

    (13) func_decl -> FUNC ID LPAREN param_list_opt RPAREN block .

    FUNC            reduce using rule 13 (func_decl -> FUNC ID LPAREN param_list_opt RPAREN block .)
    INT             reduce using rule 13 (func_decl -> FUNC ID LPAREN param_list_opt RPAREN block .)
    FLOAT           reduce using rule 13 (func_decl -> FUNC ID LPAREN param_list_opt RPAREN block .)
    BOOL            reduce using rule 13 (func_decl -> FUNC ID LPAREN param_list_opt RPAREN block .)
    CHAR            reduce using rule 13 (func_decl -> FUNC ID LPAREN param_list_opt RPAREN block .)
    STRING          reduce using rule 13 (func_decl -> FUNC ID LPAREN param_list_opt RPAREN block .)
    $end            reduce using rule 13 (func_decl -> FUNC ID LPAREN param_list_opt RPAREN block .)


state 31

    (19) block -> LBRACE . statement_list RBRACE
    (20) statement_list -> . statement_list statement
    (21) statement_list -> . empty
    (80) empty -> .

    RBRACE          reduce using rule 80 (empty -> .)
    ID              reduce using rule 80 (empty -> .)
    IF              reduce using rule 80 (empty -> .)
    WHILE           reduce using rule 80 (empty -> .)
    FOR             reduce using rule 80 (empty -> .)
    PRINT           reduce using rule 80 (empty -> .)
    INPUT           reduce using rule 80 (empty -> .)
    RETURN          reduce using rule 80 (empty -> .)
    BREAK           reduce using rule 80 (empty -> .)
    CONTINUE        reduce using rule 80 (empty -> .)
    LBRACE          reduce using rule 80 (empty -> .)
    INT             reduce using rule 80 (empty -> .)
    FLOAT           reduce using rule 80 (empty -> .)
    BOOL            reduce using rule 80 (empty -> .)
    CHAR            reduce using rule 80 (empty -> .)
    STRING          reduce using rule 80 (empty -> .)

    statement_list                 shift and go to state 33
    empty                          shift and go to state 34

state 32

    (16) param_list -> param_list COMMA param .

    COMMA           reduce using rule 16 (param_list -> param_list COMMA param .)
    RPAREN          reduce using rule 16 (param_list -> param_list COMMA param .)


state 33

    (19) block -> LBRACE statement_list . RBRACE
    (20) statement_list -> statement_list . statement
    (22) statement -> . assignment SEMI
    (23) statement -> . var_decl
    (24) statement -> . func_call SEMI
    (25) statement -> . if_stmt
    (26) statement -> . while_stmt
    (27) statement -> . for_stmt
    (28) statement -> . io_stmt SEMI
    (29) statement -> . return_stmt SEMI
    (30) statement -> . break_stmt SEMI
    (31) statement -> . continue_stmt SEMI
    (32) statement -> . block
    (33) assignment -> . location ASSIGN expr
    (6) var_decl -> . type ID SEMI
    (7) var_decl -> . type ID LBRACKET INT_LITERAL RBRACKET SEMI
    (69) func_call -> . ID LPAREN arg_list_opt RPAREN
    (36) if_stmt -> . IF LPAREN expr RPAREN block elif_part else_part_opt
    (41) while_stmt -> . WHILE LPAREN expr RPAREN block
    (42) for_stmt -> . FOR LPAREN assignment SEMI expr SEMI assignment RPAREN block
    (43) io_stmt -> . PRINT LPAREN expr RPAREN
    (44) io_stmt -> . INPUT LPAREN ID RPAREN
    (45) return_stmt -> . RETURN expr_opt
    (48) break_stmt -> . BREAK
    (49) continue_stmt -> . CONTINUE
    (19) block -> . LBRACE statement_list RBRACE
    (34) location -> . ID
    (35) location -> . ID LBRACKET expr RBRACKET
    (8) type -> . INT
    (9) type -> . FLOAT
    (10) type -> . BOOL
    (11) type -> . CHAR
    (12) type -> . STRING

    RBRACE          shift and go to state 35
    ID              shift and go to state 49
    IF              shift and go to state 50
    WHILE           shift and go to state 51
    FOR             shift and go to state 52
    PRINT           shift and go to state 53
    INPUT           shift and go to state 54
    RETURN          shift and go to state 55
    BREAK           shift and go to state 56
    CONTINUE        shift and go to state 57
    LBRACE          shift and go to state 31
    INT             shift and go to state 8
    FLOAT           shift and go to state 9
    BOOL            shift and go to state 10
    CHAR            shift and go to state 11
    STRING          shift and go to state 12

    statement                      shift and go to state 36
    assignment                     shift and go to state 37
    var_decl                       shift and go to state 38
    func_call                      shift and go to state 39
    if_stmt                        shift and go to state 40
    while_stmt                     shift and go to state 41
    for_stmt                       shift and go to state 42
    io_stmt                        shift and go to state 43
    return_stmt                    shift and go to state 44
    break_stmt                     shift and go to state 45
    continue_stmt                  shift and go to state 46
    block                          shift and go to state 47
    location                       shift and go to state 48
    type                           shift and go to state 6

state 34

    (21) statement_list -> empty .

    RBRACE          reduce using rule 21 (statement_list -> empty .)
    ID              reduce using rule 21 (statement_list -> empty .)
    IF              reduce using rule 21 (statement_list -> empty .)
    WHILE           reduce using rule 21 (statement_list -> empty .)
    FOR             reduce using rule 21 (statement_list -> empty .)
    PRINT           reduce using rule 21 (statement_list -> empty .)
    INPUT           reduce using rule 21 (statement_list -> empty .)
    RETURN          reduce using rule 21 (statement_list -> empty .)
    BREAK           reduce using rule 21 (statement_list -> empty .)
    CONTINUE        reduce using rule 21 (statement_list -> empty .)
    LBRACE          reduce using rule 21 (statement_list -> empty .)
    INT             reduce using rule 21 (statement_list -> empty .)
    FLOAT           reduce using rule 21 (statement_list -> empty .)
    BOOL            reduce using rule 21 (statement_list -> empty .)
    CHAR            reduce using rule 21 (statement_list -> empty .)
    STRING          reduce using rule 21 (statement_list -> empty .)


state 35

    (19) block -> LBRACE statement_list RBRACE .

    FUNC            reduce using rule 19 (block -> LBRACE statement_list RBRACE .)
    INT             reduce using rule 19 (block -> LBRACE statement_list RBRACE .)
    FLOAT           reduce using rule 19 (block -> LBRACE statement_list RBRACE .)
    BOOL            reduce using rule 19 (block -> LBRACE statement_list RBRACE .)
    CHAR            reduce using rule 19 (block -> LBRACE statement_list RBRACE .)
    STRING          reduce using rule 19 (block -> LBRACE statement_list RBRACE .)
    $end            reduce using rule 19 (block -> LBRACE statement_list RBRACE .)
    RBRACE          reduce using rule 19 (block -> LBRACE statement_list RBRACE .)
    ID              reduce using rule 19 (block -> LBRACE statement_list RBRACE .)
    IF              reduce using rule 19 (block -> LBRACE statement_list RBRACE .)
    WHILE           reduce using rule 19 (block -> LBRACE statement_list RBRACE .)
    FOR             reduce using rule 19 (block -> LBRACE statement_list RBRACE .)
    PRINT           reduce using rule 19 (block -> LBRACE statement_list RBRACE .)
    INPUT           reduce using rule 19 (block -> LBRACE statement_list RBRACE .)
    RETURN          reduce using rule 19 (block -> LBRACE statement_list RBRACE .)
    BREAK           reduce using rule 19 (block -> LBRACE statement_list RBRACE .)
    CONTINUE        reduce using rule 19 (block -> LBRACE statement_list RBRACE .)
    LBRACE          reduce using rule 19 (block -> LBRACE statement_list RBRACE .)
    ELIF            reduce using rule 19 (block -> LBRACE statement_list RBRACE .)
    ELSE            reduce using rule 19 (block -> LBRACE statement_list RBRACE .)


state 36

    (20) statement_list -> statement_list statement .

    RBRACE          reduce using rule 20 (statement_list -> statement_list statement .)
    ID              reduce using rule 20 (statement_list -> statement_list statement .)
    IF              reduce using rule 20 (statement_list -> statement_list statement .)
    WHILE           reduce using rule 20 (statement_list -> statement_list statement .)
    FOR             reduce using rule 20 (statement_list -> statement_list statement .)
    PRINT           reduce using rule 20 (statement_list -> statement_list statement .)
    INPUT           reduce using rule 20 (statement_list -> statement_list statement .)
    RETURN          reduce using rule 20 (statement_list -> statement_list statement .)
    BREAK           reduce using rule 20 (statement_list -> statement_list statement .)
    CONTINUE        reduce using rule 20 (statement_list -> statement_list statement .)
    LBRACE          reduce using rule 20 (statement_list -> statement_list statement .)
    INT             reduce using rule 20 (statement_list -> statement_list statement .)
    FLOAT           reduce using rule 20 (statement_list -> statement_list statement .)
    BOOL            reduce using rule 20 (statement_list -> statement_list statement .)
    CHAR            reduce using rule 20 (statement_list -> statement_list statement .)
    STRING          reduce using rule 20 (statement_list -> statement_list statement .)


state 37

    (22) statement -> assignment . SEMI

    SEMI            shift and go to state 58


state 38

    (23) statement -> var_decl .

    RBRACE          reduce using rule 23 (statement -> var_decl .)
    ID              reduce using rule 23 (statement -> var_decl .)
    IF              reduce using rule 23 (statement -> var_decl .)
    WHILE           reduce using rule 23 (statement -> var_decl .)
    FOR             reduce using rule 23 (statement -> var_decl .)
    PRINT           reduce using rule 23 (statement -> var_decl .)
    INPUT           reduce using rule 23 (statement -> var_decl .)
    RETURN          reduce using rule 23 (statement -> var_decl .)
    BREAK           reduce using rule 23 (statement -> var_decl .)
    CONTINUE        reduce using rule 23 (statement -> var_decl .)
    LBRACE          reduce using rule 23 (statement -> var_decl .)
    INT             reduce using rule 23 (statement -> var_decl .)
    FLOAT           reduce using rule 23 (statement -> var_decl .)
    BOOL            reduce using rule 23 (statement -> var_decl .)
    CHAR            reduce using rule 23 (statement -> var_decl .)
    STRING          reduce using rule 23 (statement -> var_decl .)


state 39

    (24) statement -> func_call . SEMI

    SEMI            shift and go to state 59


state 40

    (25) statement -> if_stmt .

    RBRACE          reduce using rule 25 (statement -> if_stmt .)
    ID              reduce using rule 25 (statement -> if_stmt .)
    IF              reduce using rule 25 (statement -> if_stmt .)
    WHILE           reduce using rule 25 (statement -> if_stmt .)
    FOR             reduce using rule 25 (statement -> if_stmt .)
    PRINT           reduce using rule 25 (statement -> if_stmt .)
    INPUT           reduce using rule 25 (statement -> if_stmt .)
    RETURN          reduce using rule 25 (statement -> if_stmt .)
    BREAK           reduce using rule 25 (statement -> if_stmt .)
    CONTINUE        reduce using rule 25 (statement -> if_stmt .)
    LBRACE          reduce using rule 25 (statement -> if_stmt .)
    INT             reduce using rule 25 (statement -> if_stmt .)
    FLOAT           reduce using rule 25 (statement -> if_stmt .)
    BOOL            reduce using rule 25 (statement -> if_stmt .)
    CHAR            reduce using rule 25 (statement -> if_stmt .)
    STRING          reduce using rule 25 (statement -> if_stmt .)


state 41

    (26) statement -> while_stmt .

    RBRACE          reduce using rule 26 (statement -> while_stmt .)
    ID              reduce using rule 26 (statement -> while_stmt .)
    IF              reduce using rule 26 (statement -> while_stmt .)
    WHILE           reduce using rule 26 (statement -> while_stmt .)
    FOR             reduce using rule 26 (statement -> while_stmt .)
    PRINT           reduce using rule 26 (statement -> while_stmt .)
    INPUT           reduce using rule 26 (statement -> while_stmt .)
    RETURN          reduce using rule 26 (statement -> while_stmt .)
    BREAK           reduce using rule 26 (statement -> while_stmt .)
    CONTINUE        reduce using rule 26 (statement -> while_stmt .)
    LBRACE          reduce using rule 26 (statement -> while_stmt .)
    INT             reduce using rule 26 (statement -> while_stmt .)
    FLOAT           reduce using rule 26 (statement -> while_stmt .)
    BOOL            reduce using rule 26 (statement -> while_stmt .)
    CHAR            reduce using rule 26 (statement -> while_stmt .)
    STRING          reduce using rule 26 (statement -> while_stmt .)


state 42

    (27) statement -> for_stmt .

    RBRACE          reduce using rule 27 (statement -> for_stmt .)
    ID              reduce using rule 27 (statement -> for_stmt .)
    IF              reduce using rule 27 (statement -> for_stmt .)
    WHILE           reduce using rule 27 (statement -> for_stmt .)
    FOR             reduce using rule 27 (statement -> for_stmt .)
    PRINT           reduce using rule 27 (statement -> for_stmt .)
    INPUT           reduce using rule 27 (statement -> for_stmt .)
    RETURN          reduce using rule 27 (statement -> for_stmt .)
    BREAK           reduce using rule 27 (statement -> for_stmt .)
    CONTINUE        reduce using rule 27 (statement -> for_stmt .)
    LBRACE          reduce using rule 27 (statement -> for_stmt .)
    INT             reduce using rule 27 (statement -> for_stmt .)
    FLOAT           reduce using rule 27 (statement -> for_stmt .)
    BOOL            reduce using rule 27 (statement -> for_stmt .)
    CHAR            reduce using rule 27 (statement -> for_stmt .)
    STRING          reduce using rule 27 (statement -> for_stmt .)


state 43

    (28) statement -> io_stmt . SEMI

    SEMI            shift and go to state 60


state 44

    (29) statement -> return_stmt . SEMI

    SEMI            shift and go to state 61


state 45

    (30) statement -> break_stmt . SEMI

    SEMI            shift and go to state 62


state 46

    (31) statement -> continue_stmt . SEMI

    SEMI            shift and go to state 63


state 47

    (32) statement -> block .

    RBRACE          reduce using rule 32 (statement -> block .)
    ID              reduce using rule 32 (statement -> block .)
    IF              reduce using rule 32 (statement -> block .)
    WHILE           reduce using rule 32 (statement -> block .)
    FOR             reduce using rule 32 (statement -> block .)
    PRINT           reduce using rule 32 (statement -> block .)
    INPUT           reduce using rule 32 (statement -> block .)
    RETURN          reduce using rule 32 (statement -> block .)
    BREAK           reduce using rule 32 (statement -> block .)
    CONTINUE        reduce using rule 32 (statement -> block .)
    LBRACE          reduce using rule 32 (statement -> block .)
    INT             reduce using rule 32 (statement -> block .)
    FLOAT           reduce using rule 32 (statement -> block .)
    BOOL            reduce using rule 32 (statement -> block .)
    CHAR            reduce using rule 32 (statement -> block .)
    STRING          reduce using rule 32 (statement -> block .)


state 48

    (33) assignment -> location . ASSIGN expr

    ASSIGN          shift and go to state 64


state 49

    (69) func_call -> ID . LPAREN arg_list_opt RPAREN
    (34) location -> ID .
    (35) location -> ID . LBRACKET expr RBRACKET

    LPAREN          shift and go to state 65
    ASSIGN          reduce using rule 34 (location -> ID .)
    LBRACKET        shift and go to state 66


state 50

    (36) if_stmt -> IF . LPAREN expr RPAREN block elif_part else_part_opt

    LPAREN          shift and go to state 67


state 51

    (41) while_stmt -> WHILE . LPAREN expr RPAREN block

    LPAREN          shift and go to state 68


state 52

    (42) for_stmt -> FOR . LPAREN assignment SEMI expr SEMI assignment RPAREN block

    LPAREN          shift and go to state 69


state 53

    (43) io_stmt -> PRINT . LPAREN expr RPAREN

    LPAREN          shift and go to state 70


state 54

    (44) io_stmt -> INPUT . LPAREN ID RPAREN

    LPAREN          shift and go to state 71


state 55

    (45) return_stmt -> RETURN . expr_opt
    (46) expr_opt -> . expr
    (47) expr_opt -> . empty
    (50) expr -> . expr PLUS expr
    (51) expr -> . expr MINUS expr
    (52) expr -> . expr TIMES expr
    (53) expr -> . expr DIVIDE expr
    (54) expr -> . expr MOD expr
    (55) expr -> . expr LT expr
    (56) expr -> . expr GT expr
    (57) expr -> . expr LE expr
    (58) expr -> . expr GE expr
    (59) expr -> . expr EQ expr
    (60) expr -> . expr NE expr
    (61) expr -> . expr AND expr
    (62) expr -> . expr OR expr
    (63) expr -> . MINUS expr
    (64) expr -> . NOT expr
    (65) expr -> . LPAREN expr RPAREN
    (66) expr -> . literal
    (67) expr -> . location
    (68) expr -> . func_call
    (80) empty -> .
    (74) literal -> . INT_LITERAL
    (75) literal -> . FLOAT_LITERAL
    (76) literal -> . CHAR_LITERAL
    (77) literal -> . STRING_LITERAL
    (78) literal -> . TRUE
    (79) literal -> . FALSE
    (34) location -> . ID
    (35) location -> . ID LBRACKET expr RBRACKET
    (69) func_call -> . ID LPAREN arg_list_opt RPAREN

    MINUS           shift and go to state 75
    NOT             shift and go to state 76
    LPAREN          shift and go to state 77
    SEMI            reduce using rule 80 (empty -> .)
    INT_LITERAL     shift and go to state 81
    FLOAT_LITERAL   shift and go to state 82
    CHAR_LITERAL    shift and go to state 83
    STRING_LITERAL  shift and go to state 84
    TRUE            shift and go to state 85
    FALSE           shift and go to state 86
    ID              shift and go to state 87

    expr_opt                       shift and go to state 72
    expr                           shift and go to state 73
    empty                          shift and go to state 74
    literal                        shift and go to state 78
    location                       shift and go to state 79
    func_call                      shift and go to state 80

state 56

    (48) break_stmt -> BREAK .

    SEMI            reduce using rule 48 (break_stmt -> BREAK .)


state 57

    (49) continue_stmt -> CONTINUE .

    SEMI            reduce using rule 49 (continue_stmt -> CONTINUE .)


state 58

    (22) statement -> assignment SEMI .

    RBRACE          reduce using rule 22 (statement -> assignment SEMI .)
    ID              reduce using rule 22 (statement -> assignment SEMI .)
    IF              reduce using rule 22 (statement -> assignment SEMI .)
    WHILE           reduce using rule 22 (statement -> assignment SEMI .)
    FOR             reduce using rule 22 (statement -> assignment SEMI .)
    PRINT           reduce using rule 22 (statement -> assignment SEMI .)
    INPUT           reduce using rule 22 (statement -> assignment SEMI .)
    RETURN          reduce using rule 22 (statement -> assignment SEMI .)
    BREAK           reduce using rule 22 (statement -> assignment SEMI .)
    CONTINUE        reduce using rule 22 (statement -> assignment SEMI .)
    LBRACE          reduce using rule 22 (statement -> assignment SEMI .)
    INT             reduce using rule 22 (statement -> assignment SEMI .)
    FLOAT           reduce using rule 22 (statement -> assignment SEMI .)
    BOOL            reduce using rule 22 (statement -> assignment SEMI .)
    CHAR            reduce using rule 22 (statement -> assignment SEMI .)
    STRING          reduce using rule 22 (statement -> assignment SEMI .)


state 59

    (24) statement -> func_call SEMI .

    RBRACE          reduce using rule 24 (statement -> func_call SEMI .)
    ID              reduce using rule 24 (statement -> func_call SEMI .)
    IF              reduce using rule 24 (statement -> func_call SEMI .)
    WHILE           reduce using rule 24 (statement -> func_call SEMI .)
    FOR             reduce using rule 24 (statement -> func_call SEMI .)
    PRINT           reduce using rule 24 (statement -> func_call SEMI .)
    INPUT           reduce using rule 24 (statement -> func_call SEMI .)
    RETURN          reduce using rule 24 (statement -> func_call SEMI .)
    BREAK           reduce using rule 24 (statement -> func_call SEMI .)
    CONTINUE        reduce using rule 24 (statement -> func_call SEMI .)
    LBRACE          reduce using rule 24 (statement -> func_call SEMI .)
    INT             reduce using rule 24 (statement -> func_call SEMI .)
    FLOAT           reduce using rule 24 (statement -> func_call SEMI .)
    BOOL            reduce using rule 24 (statement -> func_call SEMI .)
    CHAR            reduce using rule 24 (statement -> func_call SEMI .)
    STRING          reduce using rule 24 (statement -> func_call SEMI .)


state 60

    (28) statement -> io_stmt SEMI .

    RBRACE          reduce using rule 28 (statement -> io_stmt SEMI .)
    ID              reduce using rule 28 (statement -> io_stmt SEMI .)
    IF              reduce using rule 28 (statement -> io_stmt SEMI .)
    WHILE           reduce using rule 28 (statement -> io_stmt SEMI .)
    FOR             reduce using rule 28 (statement -> io_stmt SEMI .)
    PRINT           reduce using rule 28 (statement -> io_stmt SEMI .)
    INPUT           reduce using rule 28 (statement -> io_stmt SEMI .)
    RETURN          reduce using rule 28 (statement -> io_stmt SEMI .)
    BREAK           reduce using rule 28 (statement -> io_stmt SEMI .)
    CONTINUE        reduce using rule 28 (statement -> io_stmt SEMI .)
    LBRACE          reduce using rule 28 (statement -> io_stmt SEMI .)
    INT             reduce using rule 28 (statement -> io_stmt SEMI .)
    FLOAT           reduce using rule 28 (statement -> io_stmt SEMI .)
    BOOL            reduce using rule 28 (statement -> io_stmt SEMI .)
    CHAR            reduce using rule 28 (statement -> io_stmt SEMI .)
    STRING          reduce using rule 28 (statement -> io_stmt SEMI .)


state 61

    (29) statement -> return_stmt SEMI .

    RBRACE          reduce using rule 29 (statement -> return_stmt SEMI .)
    ID              reduce using rule 29 (statement -> return_stmt SEMI .)
    IF              reduce using rule 29 (statement -> return_stmt SEMI .)
    WHILE           reduce using rule 29 (statement -> return_stmt SEMI .)
    FOR             reduce using rule 29 (statement -> return_stmt SEMI .)
    PRINT           reduce using rule 29 (statement -> return_stmt SEMI .)
    INPUT           reduce using rule 29 (statement -> return_stmt SEMI .)
    RETURN          reduce using rule 29 (statement -> return_stmt SEMI .)
    BREAK           reduce using rule 29 (statement -> return_stmt SEMI .)
    CONTINUE        reduce using rule 29 (statement -> return_stmt SEMI .)
    LBRACE          reduce using rule 29 (statement -> return_stmt SEMI .)
    INT             reduce using rule 29 (statement -> return_stmt SEMI .)
    FLOAT           reduce using rule 29 (statement -> return_stmt SEMI .)
    BOOL            reduce using rule 29 (statement -> return_stmt SEMI .)
    CHAR            reduce using rule 29 (statement -> return_stmt SEMI .)
    STRING          reduce using rule 29 (statement -> return_stmt SEMI .)


state 62

    (30) statement -> break_stmt SEMI .

    RBRACE          reduce using rule 30 (statement -> break_stmt SEMI .)
    ID              reduce using rule 30 (statement -> break_stmt SEMI .)
    IF              reduce using rule 30 (statement -> break_stmt SEMI .)
    WHILE           reduce using rule 30 (statement -> break_stmt SEMI .)
    FOR             reduce using rule 30 (statement -> break_stmt SEMI .)
    PRINT           reduce using rule 30 (statement -> break_stmt SEMI .)
    INPUT           reduce using rule 30 (statement -> break_stmt SEMI .)
    RETURN          reduce using rule 30 (statement -> break_stmt SEMI .)
    BREAK           reduce using rule 30 (statement -> break_stmt SEMI .)
    CONTINUE        reduce using rule 30 (statement -> break_stmt SEMI .)
    LBRACE          reduce using rule 30 (statement -> break_stmt SEMI .)
    INT             reduce using rule 30 (statement -> break_stmt SEMI .)
    FLOAT           reduce using rule 30 (statement -> break_stmt SEMI .)
    BOOL            reduce using rule 30 (statement -> break_stmt SEMI .)
    CHAR            reduce using rule 30 (statement -> break_stmt SEMI .)
    STRING          reduce using rule 30 (statement -> break_stmt SEMI .)


state 63

    (31) statement -> continue_stmt SEMI .

    RBRACE          reduce using rule 31 (statement -> continue_stmt SEMI .)
    ID              reduce using rule 31 (statement -> continue_stmt SEMI .)
    IF              reduce using rule 31 (statement -> continue_stmt SEMI .)
    WHILE           reduce using rule 31 (statement -> continue_stmt SEMI .)
    FOR             reduce using rule 31 (statement -> continue_stmt SEMI .)
    PRINT           reduce using rule 31 (statement -> continue_stmt SEMI .)
    INPUT           reduce using rule 31 (statement -> continue_stmt SEMI .)
    RETURN          reduce using rule 31 (statement -> continue_stmt SEMI .)
    BREAK           reduce using rule 31 (statement -> continue_stmt SEMI .)
    CONTINUE        reduce using rule 31 (statement -> continue_stmt SEMI .)
    LBRACE          reduce using rule 31 (statement -> continue_stmt SEMI .)
    INT             reduce using rule 31 (statement -> continue_stmt SEMI .)
    FLOAT           reduce using rule 31 (statement -> continue_stmt SEMI .)
    BOOL            reduce using rule 31 (statement -> continue_stmt SEMI .)
    CHAR            reduce using rule 31 (statement -> continue_stmt SEMI .)
    STRING          reduce using rule 31 (statement -> continue_stmt SEMI .)


state 64

    (33) assignment -> location ASSIGN . expr
    (50) expr -> . expr PLUS expr
    (51) expr -> . expr MINUS expr
    (52) expr -> . expr TIMES expr
    (53) expr -> . expr DIVIDE expr
    (54) expr -> . expr MOD expr
    (55) expr -> . expr LT expr
    (56) expr -> . expr GT expr
    (57) expr -> . expr LE expr
    (58) expr -> . expr GE expr
    (59) expr -> . expr EQ expr
    (60) expr -> . expr NE expr
    (61) expr -> . expr AND expr
    (62) expr -> . expr OR expr
    (63) expr -> . MINUS expr
    (64) expr -> . NOT expr
    (65) expr -> . LPAREN expr RPAREN
    (66) expr -> . literal
    (67) expr -> . location
    (68) expr -> . func_call
    (74) literal -> . INT_LITERAL
    (75) literal -> . FLOAT_LITERAL
    (76) literal -> . CHAR_LITERAL
    (77) literal -> . STRING_LITERAL
    (78) literal -> . TRUE
    (79) literal -> . FALSE
    (34) location -> . ID
    (35) location -> . ID LBRACKET expr RBRACKET
    (69) func_call -> . ID LPAREN arg_list_opt RPAREN

    MINUS           shift and go to state 75
    NOT             shift and go to state 76
    LPAREN          shift and go to state 77
    INT_LITERAL     shift and go to state 81
    FLOAT_LITERAL   shift and go to state 82
    CHAR_LITERAL    shift and go to state 83
    STRING_LITERAL  shift and go to state 84
    TRUE            shift and go to state 85
    FALSE           shift and go to state 86
    ID              shift and go to state 87

    location                       shift and go to state 79
    expr                           shift and go to state 88
    literal                        shift and go to state 78
    func_call                      shift and go to state 80

state 65

    (69) func_call -> ID LPAREN . arg_list_opt RPAREN
    (70) arg_list_opt -> . arg_list
    (71) arg_list_opt -> . empty
    (72) arg_list -> . arg_list COMMA expr
    (73) arg_list -> . expr
    (80) empty -> .
    (50) expr -> . expr PLUS expr
    (51) expr -> . expr MINUS expr
    (52) expr -> . expr TIMES expr
    (53) expr -> . expr DIVIDE expr
    (54) expr -> . expr MOD expr
    (55) expr -> . expr LT expr
    (56) expr -> . expr GT expr
    (57) expr -> . expr LE expr
    (58) expr -> . expr GE expr
    (59) expr -> . expr EQ expr
    (60) expr -> . expr NE expr
    (61) expr -> . expr AND expr
    (62) expr -> . expr OR expr
    (63) expr -> . MINUS expr
    (64) expr -> . NOT expr
    (65) expr -> . LPAREN expr RPAREN
    (66) expr -> . literal
    (67) expr -> . location
    (68) expr -> . func_call
    (74) literal -> . INT_LITERAL
    (75) literal -> . FLOAT_LITERAL
    (76) literal -> . CHAR_LITERAL
    (77) literal -> . STRING_LITERAL
    (78) literal -> . TRUE
    (79) literal -> . FALSE
    (34) location -> . ID
    (35) location -> . ID LBRACKET expr RBRACKET
    (69) func_call -> . ID LPAREN arg_list_opt RPAREN

    RPAREN          reduce using rule 80 (empty -> .)
    MINUS           shift and go to state 75
    NOT             shift and go to state 76
    LPAREN          shift and go to state 77
    INT_LITERAL     shift and go to state 81
    FLOAT_LITERAL   shift and go to state 82
    CHAR_LITERAL    shift and go to state 83
    STRING_LITERAL  shift and go to state 84
    TRUE            shift and go to state 85
    FALSE           shift and go to state 86
    ID              shift and go to state 87

    arg_list_opt                   shift and go to state 89
    arg_list                       shift and go to state 90
    empty                          shift and go to state 91
    expr                           shift and go to state 92
    literal                        shift and go to state 78
    location                       shift and go to state 79
    func_call                      shift and go to state 80

state 66

    (35) location -> ID LBRACKET . expr RBRACKET
    (50) expr -> . expr PLUS expr
    (51) expr -> . expr MINUS expr
    (52) expr -> . expr TIMES expr
    (53) expr -> . expr DIVIDE expr
    (54) expr -> . expr MOD expr
    (55) expr -> . expr LT expr
    (56) expr -> . expr GT expr
    (57) expr -> . expr LE expr
    (58) expr -> . expr GE expr
    (59) expr -> . expr EQ expr
    (60) expr -> . expr NE expr
    (61) expr -> . expr AND expr
    (62) expr -> . expr OR expr
    (63) expr -> . MINUS expr
    (64) expr -> . NOT expr
    (65) expr -> . LPAREN expr RPAREN
    (66) expr -> . literal
    (67) expr -> . location
    (68) expr -> . func_call
    (74) literal -> . INT_LITERAL
    (75) literal -> . FLOAT_LITERAL
    (76) literal -> . CHAR_LITERAL
    (77) literal -> . STRING_LITERAL
    (78) literal -> . TRUE
    (79) literal -> . FALSE
    (34) location -> . ID
    (35) location -> . ID LBRACKET expr RBRACKET
    (69) func_call -> . ID LPAREN arg_list_opt RPAREN

    MINUS           shift and go to state 75
    NOT             shift and go to state 76
    LPAREN          shift and go to state 77
    INT_LITERAL     shift and go to state 81
    FLOAT_LITERAL   shift and go to state 82
    CHAR_LITERAL    shift and go to state 83
    STRING_LITERAL  shift and go to state 84
    TRUE            shift and go to state 85
    FALSE           shift and go to state 86
    ID              shift and go to state 87

    expr                           shift and go to state 93
    literal                        shift and go to state 78
    location                       shift and go to state 79
    func_call                      shift and go to state 80

state 67

    (36) if_stmt -> IF LPAREN . expr RPAREN block elif_part else_part_opt
    (50) expr -> . expr PLUS expr
    (51) expr -> . expr MINUS expr
    (52) expr -> . expr TIMES expr
    (53) expr -> . expr DIVIDE expr
    (54) expr -> . expr MOD expr
    (55) expr -> . expr LT expr
    (56) expr -> . expr GT expr
    (57) expr -> . expr LE expr
    (58) expr -> . expr GE expr
    (59) expr -> . expr EQ expr
    (60) expr -> . expr NE expr
    (61) expr -> . expr AND expr
    (62) expr -> . expr OR expr
    (63) expr -> . MINUS expr
    (64) expr -> . NOT expr
    (65) expr -> . LPAREN expr RPAREN
    (66) expr -> . literal
    (67) expr -> . location
    (68) expr -> . func_call
    (74) literal -> . INT_LITERAL
    (75) literal -> . FLOAT_LITERAL
    (76) literal -> . CHAR_LITERAL
    (77) literal -> . STRING_LITERAL
    (78) literal -> . TRUE
    (79) literal -> . FALSE
    (34) location -> . ID
    (35) location -> . ID LBRACKET expr RBRACKET
    (69) func_call -> . ID LPAREN arg_list_opt RPAREN

    MINUS           shift and go to state 75
    NOT             shift and go to state 76
    LPAREN          shift and go to state 77
    INT_LITERAL     shift and go to state 81
    FLOAT_LITERAL   shift and go to state 82
    CHAR_LITERAL    shift and go to state 83
    STRING_LITERAL  shift and go to state 84
    TRUE            shift and go to state 85
    FALSE           shift and go to state 86
    ID              shift and go to state 87

    expr                           shift and go to state 94
    literal                        shift and go to state 78
    location                       shift and go to state 79
    func_call                      shift and go to state 80

state 68

    (41) while_stmt -> WHILE LPAREN . expr RPAREN block
    (50) expr -> . expr PLUS expr
    (51) expr -> . expr MINUS expr
    (52) expr -> . expr TIMES expr
    (53) expr -> . expr DIVIDE expr
    (54) expr -> . expr MOD expr
    (55) expr -> . expr LT expr
    (56) expr -> . expr GT expr
    (57) expr -> . expr LE expr
    (58) expr -> . expr GE expr
    (59) expr -> . expr EQ expr
    (60) expr -> . expr NE expr
    (61) expr -> . expr AND expr
    (62) expr -> . expr OR expr
    (63) expr -> . MINUS expr
    (64) expr -> . NOT expr
    (65) expr -> . LPAREN expr RPAREN
    (66) expr -> . literal
    (67) expr -> . location
    (68) expr -> . func_call
    (74) literal -> . INT_LITERAL
    (75) literal -> . FLOAT_LITERAL
    (76) literal -> . CHAR_LITERAL
    (77) literal -> . STRING_LITERAL
    (78) literal -> . TRUE
    (79) literal -> . FALSE
    (34) location -> . ID
    (35) location -> . ID LBRACKET expr RBRACKET
    (69) func_call -> . ID LPAREN arg_list_opt RPAREN

    MINUS           shift and go to state 75
    NOT             shift and go to state 76
    LPAREN          shift and go to state 77
    INT_LITERAL     shift and go to state 81
    FLOAT_LITERAL   shift and go to state 82
    CHAR_LITERAL    shift and go to state 83
    STRING_LITERAL  shift and go to state 84
    TRUE            shift and go to state 85
    FALSE           shift and go to state 86
    ID              shift and go to state 87

    expr                           shift and go to state 95
    literal                        shift and go to state 78
    location                       shift and go to state 79
    func_call                      shift and go to state 80

state 69

    (42) for_stmt -> FOR LPAREN . assignment SEMI expr SEMI assignment RPAREN block
    (33) assignment -> . location ASSIGN expr
    (34) location -> . ID
    (35) location -> . ID LBRACKET expr RBRACKET

    ID              shift and go to state 97

    assignment                     shift and go to state 96
    location                       shift and go to state 48

state 70

    (43) io_stmt -> PRINT LPAREN . expr RPAREN
    (50) expr -> . expr PLUS expr
    (51) expr -> . expr MINUS expr
    (52) expr -> . expr TIMES expr
    (53) expr -> . expr DIVIDE expr
    (54) expr -> . expr MOD expr
    (55) expr -> . expr LT expr
    (56) expr -> . expr GT expr
    (57) expr -> . expr LE expr
    (58) expr -> . expr GE expr
    (59) expr -> . expr EQ expr
    (60) expr -> . expr NE expr
    (61) expr -> . expr AND expr
    (62) expr -> . expr OR expr
    (63) expr -> . MINUS expr
    (64) expr -> . NOT expr
    (65) expr -> . LPAREN expr RPAREN
    (66) expr -> . literal
    (67) expr -> . location
    (68) expr -> . func_call
    (74) literal -> . INT_LITERAL
    (75) literal -> . FLOAT_LITERAL
    (76) literal -> . CHAR_LITERAL
    (77) literal -> . STRING_LITERAL
    (78) literal -> . TRUE
    (79) literal -> . FALSE
    (34) location -> . ID
    (35) location -> . ID LBRACKET expr RBRACKET
    (69) func_call -> . ID LPAREN arg_list_opt RPAREN

    MINUS           shift and go to state 75
    NOT             shift and go to state 76
    LPAREN          shift and go to state 77
    INT_LITERAL     shift and go to state 81
    FLOAT_LITERAL   shift and go to state 82
    CHAR_LITERAL    shift and go to state 83
    STRING_LITERAL  shift and go to state 84
    TRUE            shift and go to state 85
    FALSE           shift and go to state 86
    ID              shift and go to state 87

    expr                           shift and go to state 98
    literal                        shift and go to state 78
    location                       shift and go to state 79
    func_call                      shift and go to state 80

state 71

    (44) io_stmt -> INPUT LPAREN . ID RPAREN

    ID              shift and go to state 99


state 72

    (45) return_stmt -> RETURN expr_opt .

    SEMI            reduce using rule 45 (return_stmt -> RETURN expr_opt .)


state 73

    (46) expr_opt -> expr .
    (50) expr -> expr . PLUS expr
    (51) expr -> expr . MINUS expr
    (52) expr -> expr . TIMES expr
    (53) expr -> expr . DIVIDE expr
    (54) expr -> expr . MOD expr
    (55) expr -> expr . LT expr
    (56) expr -> expr . GT expr
    (57) expr -> expr . LE expr
    (58) expr -> expr . GE expr
    (59) expr -> expr . EQ expr
    (60) expr -> expr . NE expr
    (61) expr -> expr . AND expr
    (62) expr -> expr . OR expr

    SEMI            reduce using rule 46 (expr_opt -> expr .)
    PLUS            shift and go to state 100
    MINUS           shift and go to state 101
    TIMES           shift and go to state 102
    DIVIDE          shift and go to state 103
    MOD             shift and go to state 104
    LT              shift and go to state 105
    GT              shift and go to state 106
    LE              shift and go to state 107
    GE              shift and go to state 108
    EQ              shift and go to state 109
    NE              shift and go to state 110
    AND             shift and go to state 111
    OR              shift and go to state 112


state 74

    (47) expr_opt -> empty .

    SEMI            reduce using rule 47 (expr_opt -> empty .)


state 75

    (63) expr -> MINUS . expr
    (50) expr -> . expr PLUS expr
    (51) expr -> . expr MINUS expr
    (52) expr -> . expr TIMES expr
    (53) expr -> . expr DIVIDE expr
    (54) expr -> . expr MOD expr
    (55) expr -> . expr LT expr
    (56) expr -> . expr GT expr
    (57) expr -> . expr LE expr
    (58) expr -> . expr GE expr
    (59) expr -> . expr EQ expr
    (60) expr -> . expr NE expr
    (61) expr -> . expr AND expr
    (62) expr -> . expr OR expr
    (63) expr -> . MINUS expr
    (64) expr -> . NOT expr
    (65) expr -> . LPAREN expr RPAREN
    (66) expr -> . literal
    (67) expr -> . location
    (68) expr -> . func_call
    (74) literal -> . INT_LITERAL
    (75) literal -> . FLOAT_LITERAL
    (76) literal -> . CHAR_LITERAL
    (77) literal -> . STRING_LITERAL
    (78) literal -> . TRUE
    (79) literal -> . FALSE
    (34) location -> . ID
    (35) location -> . ID LBRACKET expr RBRACKET
    (69) func_call -> . ID LPAREN arg_list_opt RPAREN

    MINUS           shift and go to state 75
    NOT             shift and go to state 76
    LPAREN          shift and go to state 77
    INT_LITERAL     shift and go to state 81
    FLOAT_LITERAL   shift and go to state 82
    CHAR_LITERAL    shift and go to state 83
    STRING_LITERAL  shift and go to state 84
    TRUE            shift and go to state 85
    FALSE           shift and go to state 86
    ID              shift and go to state 87

    expr                           shift and go to state 113
    literal                        shift and go to state 78
    location                       shift and go to state 79
    func_call                      shift and go to state 80

state 76

    (64) expr -> NOT . expr
    (50) expr -> . expr PLUS expr
    (51) expr -> . expr MINUS expr
    (52) expr -> . expr TIMES expr
    (53) expr -> . expr DIVIDE expr
    (54) expr -> . expr MOD expr
    (55) expr -> . expr LT expr
    (56) expr -> . expr GT expr
    (57) expr -> . expr LE expr
    (58) expr -> . expr GE expr
    (59) expr -> . expr EQ expr
    (60) expr -> . expr NE expr
    (61) expr -> . expr AND expr
    (62) expr -> . expr OR expr
    (63) expr -> . MINUS expr
    (64) expr -> . NOT expr
    (65) expr -> . LPAREN expr RPAREN
    (66) expr -> . literal
    (67) expr -> . location
    (68) expr -> . func_call
    (74) literal -> . INT_LITERAL
    (75) literal -> . FLOAT_LITERAL
    (76) literal -> . CHAR_LITERAL
    (77) literal -> . STRING_LITERAL
    (78) literal -> . TRUE
    (79) literal -> . FALSE
    (34) location -> . ID
    (35) location -> . ID LBRACKET expr RBRACKET
    (69) func_call -> . ID LPAREN arg_list_opt RPAREN

    MINUS           shift and go to state 75
    NOT             shift and go to state 76
    LPAREN          shift and go to state 77
    INT_LITERAL     shift and go to state 81
    FLOAT_LITERAL   shift and go to state 82
    CHAR_LITERAL    shift and go to state 83
    STRING_LITERAL  shift and go to state 84
    TRUE            shift and go to state 85
    FALSE           shift and go to state 86
    ID              shift and go to state 87

    expr                           shift and go to state 114
    literal                        shift and go to state 78
    location                       shift and go to state 79
    func_call                      shift and go to state 80

state 77

    (65) expr -> LPAREN . expr RPAREN
    (50) expr -> . expr PLUS expr
    (51) expr -> . expr MINUS expr
    (52) expr -> . expr TIMES expr
    (53) expr -> . expr DIVIDE expr
    (54) expr -> . expr MOD expr
    (55) expr -> . expr LT expr
    (56) expr -> . expr GT expr
    (57) expr -> . expr LE expr
    (58) expr -> . expr GE expr
    (59) expr -> . expr EQ expr
    (60) expr -> . expr NE expr
    (61) expr -> . expr AND expr
    (62) expr -> . expr OR expr
    (63) expr -> . MINUS expr
    (64) expr -> . NOT expr
    (65) expr -> . LPAREN expr RPAREN
    (66) expr -> . literal
    (67) expr -> . location
    (68) expr -> . func_call
    (74) literal -> . INT_LITERAL
    (75) literal -> . FLOAT_LITERAL
    (76) literal -> . CHAR_LITERAL
    (77) literal -> . STRING_LITERAL
    (78) literal -> . TRUE
    (79) literal -> . FALSE
    (34) location -> . ID
    (35) location -> . ID LBRACKET expr RBRACKET
    (69) func_call -> . ID LPAREN arg_list_opt RPAREN

    MINUS           shift and go to state 75
    NOT             shift and go to state 76
    LPAREN          shift and go to state 77
    INT_LITERAL     shift and go to state 81
    FLOAT_LITERAL   shift and go to state 82
    CHAR_LITERAL    shift and go to state 83
    STRING_LITERAL  shift and go to state 84
    TRUE            shift and go to state 85
    FALSE           shift and go to state 86
    ID              shift and go to state 87

    expr                           shift and go to state 115
    literal                        shift and go to state 78
    location                       shift and go to state 79
    func_call                      shift and go to state 80

state 78

    (66) expr -> literal .

    PLUS            reduce using rule 66 (expr -> literal .)
    MINUS           reduce using rule 66 (expr -> literal .)
    TIMES           reduce using rule 66 (expr -> literal .)
    DIVIDE          reduce using rule 66 (expr -> literal .)
    MOD             reduce using rule 66 (expr -> literal .)
    LT              reduce using rule 66 (expr -> literal .)
    GT              reduce using rule 66 (expr -> literal .)
    LE              reduce using rule 66 (expr -> literal .)
    GE              reduce using rule 66 (expr -> literal .)
    EQ              reduce using rule 66 (expr -> literal .)
    NE              reduce using rule 66 (expr -> literal .)
    AND             reduce using rule 66 (expr -> literal .)
    OR              reduce using rule 66 (expr -> literal .)
    SEMI            reduce using rule 66 (expr -> literal .)
    RPAREN          reduce using rule 66 (expr -> literal .)
    COMMA           reduce using rule 66 (expr -> literal .)
    RBRACKET        reduce using rule 66 (expr -> literal .)


state 79

    (67) expr -> location .

    PLUS            reduce using rule 67 (expr -> location .)
    MINUS           reduce using rule 67 (expr -> location .)
    TIMES           reduce using rule 67 (expr -> location .)
    DIVIDE          reduce using rule 67 (expr -> location .)
    MOD             reduce using rule 67 (expr -> location .)
    LT              reduce using rule 67 (expr -> location .)
    GT              reduce using rule 67 (expr -> location .)
    LE              reduce using rule 67 (expr -> location .)
    GE              reduce using rule 67 (expr -> location .)
    EQ              reduce using rule 67 (expr -> location .)
    NE              reduce using rule 67 (expr -> location .)
    AND             reduce using rule 67 (expr -> location .)
    OR              reduce using rule 67 (expr -> location .)
    SEMI            reduce using rule 67 (expr -> location .)
    RPAREN          reduce using rule 67 (expr -> location .)
    COMMA           reduce using rule 67 (expr -> location .)
    RBRACKET        reduce using rule 67 (expr -> location .)


state 80

    (68) expr -> func_call .

    PLUS            reduce using rule 68 (expr -> func_call .)
    MINUS           reduce using rule 68 (expr -> func_call .)
    TIMES           reduce using rule 68 (expr -> func_call .)
    DIVIDE          reduce using rule 68 (expr -> func_call .)
    MOD             reduce using rule 68 (expr -> func_call .)
    LT              reduce using rule 68 (expr -> func_call .)
    GT              reduce using rule 68 (expr -> func_call .)
    LE              reduce using rule 68 (expr -> func_call .)
    GE              reduce using rule 68 (expr -> func_call .)
    EQ              reduce using rule 68 (expr -> func_call .)
    NE              reduce using rule 68 (expr -> func_call .)
    AND             reduce using rule 68 (expr -> func_call .)
    OR              reduce using rule 68 (expr -> func_call .)
    SEMI            reduce using rule 68 (expr -> func_call .)
    RPAREN          reduce using rule 68 (expr -> func_call .)
    COMMA           reduce using rule 68 (expr -> func_call .)
    RBRACKET        reduce using rule 68 (expr -> func_call .)


state 81

    (74) literal -> INT_LITERAL .

    PLUS            reduce using rule 74 (literal -> INT_LITERAL .)
    MINUS           reduce using rule 74 (literal -> INT_LITERAL .)
    TIMES           reduce using rule 74 (literal -> INT_LITERAL .)
    DIVIDE          reduce using rule 74 (literal -> INT_LITERAL .)
    MOD             reduce using rule 74 (literal -> INT_LITERAL .)
    LT              reduce using rule 74 (literal -> INT_LITERAL .)
    GT              reduce using rule 74 (literal -> INT_LITERAL .)
    LE              reduce using rule 74 (literal -> INT_LITERAL .)
    GE              reduce using rule 74 (literal -> INT_LITERAL .)
    EQ              reduce using rule 74 (literal -> INT_LITERAL .)
    NE              reduce using rule 74 (literal -> INT_LITERAL .)
    AND             reduce using rule 74 (literal -> INT_LITERAL .)
    OR              reduce using rule 74 (literal -> INT_LITERAL .)
    SEMI            reduce using rule 74 (literal -> INT_LITERAL .)
    RPAREN          reduce using rule 74 (literal -> INT_LITERAL .)
    COMMA           reduce using rule 74 (literal -> INT_LITERAL .)
    RBRACKET        reduce using rule 74 (literal -> INT_LITERAL .)


state 82

    (75) literal -> FLOAT_LITERAL .

    PLUS            reduce using rule 75 (literal -> FLOAT_LITERAL .)
    MINUS           reduce using rule 75 (literal -> FLOAT_LITERAL .)
    TIMES           reduce using rule 75 (literal -> FLOAT_LITERAL .)
    DIVIDE          reduce using rule 75 (literal -> FLOAT_LITERAL .)
    MOD             reduce using rule 75 (literal -> FLOAT_LITERAL .)
    LT              reduce using rule 75 (literal -> FLOAT_LITERAL .)
    GT              reduce using rule 75 (literal -> FLOAT_LITERAL .)
    LE              reduce using rule 75 (literal -> FLOAT_LITERAL .)
    GE              reduce using rule 75 (literal -> FLOAT_LITERAL .)
    EQ              reduce using rule 75 (literal -> FLOAT_LITERAL .)
    NE              reduce using rule 75 (literal -> FLOAT_LITERAL .)
    AND             reduce using rule 75 (literal -> FLOAT_LITERAL .)
    OR              reduce using rule 75 (literal -> FLOAT_LITERAL .)
    SEMI            reduce using rule 75 (literal -> FLOAT_LITERAL .)
    RPAREN          reduce using rule 75 (literal -> FLOAT_LITERAL .)
    COMMA           reduce using rule 75 (literal -> FLOAT_LITERAL .)
    RBRACKET        reduce using rule 75 (literal -> FLOAT_LITERAL .)


state 83

    (76) literal -> CHAR_LITERAL .

    PLUS            reduce using rule 76 (literal -> CHAR_LITERAL .)
    MINUS           reduce using rule 76 (literal -> CHAR_LITERAL .)
    TIMES           reduce using rule 76 (literal -> CHAR_LITERAL .)
    DIVIDE          reduce using rule 76 (literal -> CHAR_LITERAL .)
    MOD             reduce using rule 76 (literal -> CHAR_LITERAL .)
    LT              reduce using rule 76 (literal -> CHAR_LITERAL .)
    GT              reduce using rule 76 (literal -> CHAR_LITERAL .)
    LE              reduce using rule 76 (literal -> CHAR_LITERAL .)
    GE              reduce using rule 76 (literal -> CHAR_LITERAL .)
    EQ              reduce using rule 76 (literal -> CHAR_LITERAL .)
    NE              reduce using rule 76 (literal -> CHAR_LITERAL .)
    AND             reduce using rule 76 (literal -> CHAR_LITERAL .)
    OR              reduce using rule 76 (literal -> CHAR_LITERAL .)
    SEMI            reduce using rule 76 (literal -> CHAR_LITERAL .)
    RPAREN          reduce using rule 76 (literal -> CHAR_LITERAL .)
    COMMA           reduce using rule 76 (literal -> CHAR_LITERAL .)
    RBRACKET        reduce using rule 76 (literal -> CHAR_LITERAL .)


state 84

    (77) literal -> STRING_LITERAL .

    PLUS            reduce using rule 77 (literal -> STRING_LITERAL .)
    MINUS           reduce using rule 77 (literal -> STRING_LITERAL .)
    TIMES           reduce using rule 77 (literal -> STRING_LITERAL .)
    DIVIDE          reduce using rule 77 (literal -> STRING_LITERAL .)
    MOD             reduce using rule 77 (literal -> STRING_LITERAL .)
    LT              reduce using rule 77 (literal -> STRING_LITERAL .)
    GT              reduce using rule 77 (literal -> STRING_LITERAL .)
    LE              reduce using rule 77 (literal -> STRING_LITERAL .)
    GE              reduce using rule 77 (literal -> STRING_LITERAL .)
    EQ              reduce using rule 77 (literal -> STRING_LITERAL .)
    NE              reduce using rule 77 (literal -> STRING_LITERAL .)
    AND             reduce using rule 77 (literal -> STRING_LITERAL .)
    OR              reduce using rule 77 (literal -> STRING_LITERAL .)
    SEMI            reduce using rule 77 (literal -> STRING_LITERAL .)
    RPAREN          reduce using rule 77 (literal -> STRING_LITERAL .)
    COMMA           reduce using rule 77 (literal -> STRING_LITERAL .)
    RBRACKET        reduce using rule 77 (literal -> STRING_LITERAL .)


state 85

    (78) literal -> TRUE .

    PLUS            reduce using rule 78 (literal -> TRUE .)
    MINUS           reduce using rule 78 (literal -> TRUE .)
    TIMES           reduce using rule 78 (literal -> TRUE .)
    DIVIDE          reduce using rule 78 (literal -> TRUE .)
    MOD             reduce using rule 78 (literal -> TRUE .)
    LT              reduce using rule 78 (literal -> TRUE .)
    GT              reduce using rule 78 (literal -> TRUE .)
    LE              reduce using rule 78 (literal -> TRUE .)
    GE              reduce using rule 78 (literal -> TRUE .)
    EQ              reduce using rule 78 (literal -> TRUE .)
    NE              reduce using rule 78 (literal -> TRUE .)
    AND             reduce using rule 78 (literal -> TRUE .)
    OR              reduce using rule 78 (literal -> TRUE .)
    SEMI            reduce using rule 78 (literal -> TRUE .)
    RPAREN          reduce using rule 78 (literal -> TRUE .)
    COMMA           reduce using rule 78 (literal -> TRUE .)
    RBRACKET        reduce using rule 78 (literal -> TRUE .)


state 86

    (79) literal -> FALSE .

    PLUS            reduce using rule 79 (literal -> FALSE .)
    MINUS           reduce using rule 79 (literal -> FALSE .)
    TIMES           reduce using rule 79 (literal -> FALSE .)
    DIVIDE          reduce using rule 79 (literal -> FALSE .)
    MOD             reduce using rule 79 (literal -> FALSE .)
    LT              reduce using rule 79 (literal -> FALSE .)
    GT              reduce using rule 79 (literal -> FALSE .)
    LE              reduce using rule 79 (literal -> FALSE .)
    GE              reduce using rule 79 (literal -> FALSE .)
    EQ              reduce using rule 79 (literal -> FALSE .)
    NE              reduce using rule 79 (literal -> FALSE .)
    AND             reduce using rule 79 (literal -> FALSE .)
    OR              reduce using rule 79 (literal -> FALSE .)
    SEMI            reduce using rule 79 (literal -> FALSE .)
    RPAREN          reduce using rule 79 (literal -> FALSE .)
    COMMA           reduce using rule 79 (literal -> FALSE .)
    RBRACKET        reduce using rule 79 (literal -> FALSE .)


state 87

    (34) location -> ID .
    (35) location -> ID . LBRACKET expr RBRACKET
    (69) func_call -> ID . LPAREN arg_list_opt RPAREN

    PLUS            reduce using rule 34 (location -> ID .)
    MINUS           reduce using rule 34 (location -> ID .)
    TIMES           reduce using rule 34 (location -> ID .)
    DIVIDE          reduce using rule 34 (location -> ID .)
    MOD             reduce using rule 34 (location -> ID .)
    LT              reduce using rule 34 (location -> ID .)
    GT              reduce using rule 34 (location -> ID .)
    LE              reduce using rule 34 (location -> ID .)
    GE              reduce using rule 34 (location -> ID .)
    EQ              reduce using rule 34 (location -> ID .)
    NE              reduce using rule 34 (location -> ID .)
    AND             reduce using rule 34 (location -> ID .)
    OR              reduce using rule 34 (location -> ID .)
    SEMI            reduce using rule 34 (location -> ID .)
    RPAREN          reduce using rule 34 (location -> ID .)
    COMMA           reduce using rule 34 (location -> ID .)
    RBRACKET        reduce using rule 34 (location -> ID .)
    LBRACKET        shift and go to state 66
    LPAREN          shift and go to state 65


state 88

    (33) assignment -> location ASSIGN expr .
    (50) expr -> expr . PLUS expr
    (51) expr -> expr . MINUS expr
    (52) expr -> expr . TIMES expr
    (53) expr -> expr . DIVIDE expr
    (54) expr -> expr . MOD expr
    (55) expr -> expr . LT expr
    (56) expr -> expr . GT expr
    (57) expr -> expr . LE expr
    (58) expr -> expr . GE expr
    (59) expr -> expr . EQ expr
    (60) expr -> expr . NE expr
    (61) expr -> expr . AND expr
    (62) expr -> expr . OR expr

    SEMI            reduce using rule 33 (assignment -> location ASSIGN expr .)
    RPAREN          reduce using rule 33 (assignment -> location ASSIGN expr .)
    PLUS            shift and go to state 100
    MINUS           shift and go to state 101
    TIMES           shift and go to state 102
    DIVIDE          shift and go to state 103
    MOD             shift and go to state 104
    LT              shift and go to state 105
    GT              shift and go to state 106
    LE              shift and go to state 107
    GE              shift and go to state 108
    EQ              shift and go to state 109
    NE              shift and go to state 110
    AND             shift and go to state 111
    OR              shift and go to state 112


state 89

    (69) func_call -> ID LPAREN arg_list_opt . RPAREN

    RPAREN          shift and go to state 116


state 90

    (70) arg_list_opt -> arg_list .
    (72) arg_list -> arg_list . COMMA expr

    RPAREN          reduce using rule 70 (arg_list_opt -> arg_list .)
    COMMA           shift and go to state 117


state 91

    (71) arg_list_opt -> empty .

    RPAREN          reduce using rule 71 (arg_list_opt -> empty .)


state 92

    (73) arg_list -> expr .
    (50) expr -> expr . PLUS expr
    (51) expr -> expr . MINUS expr
    (52) expr -> expr . TIMES expr
    (53) expr -> expr . DIVIDE expr
    (54) expr -> expr . MOD expr
    (55) expr -> expr . LT expr
    (56) expr -> expr . GT expr
    (57) expr -> expr . LE expr
    (58) expr -> expr . GE expr
    (59) expr -> expr . EQ expr
    (60) expr -> expr . NE expr
    (61) expr -> expr . AND expr
    (62) expr -> expr . OR expr

    COMMA           reduce using rule 73 (arg_list -> expr .)
    RPAREN          reduce using rule 73 (arg_list -> expr .)
    PLUS            shift and go to state 100
    MINUS           shift and go to state 101
    TIMES           shift and go to state 102
    DIVIDE          shift and go to state 103
    MOD             shift and go to state 104
    LT              shift and go to state 105
    GT              shift and go to state 106
    LE              shift and go to state 107
    GE              shift and go to state 108
    EQ              shift and go to state 109
    NE              shift and go to state 110
    AND             shift and go to state 111
    OR              shift and go to state 112


state 93

    (35) location -> ID LBRACKET expr . RBRACKET
    (50) expr -> expr . PLUS expr
    (51) expr -> expr . MINUS expr
    (52) expr -> expr . TIMES expr
    (53) expr -> expr . DIVIDE expr
    (54) expr -> expr . MOD expr
    (55) expr -> expr . LT expr
    (56) expr -> expr . GT expr
    (57) expr -> expr . LE expr
    (58) expr -> expr . GE expr
    (59) expr -> expr . EQ expr
    (60) expr -> expr . NE expr
    (61) expr -> expr . AND expr
    (62) expr -> expr . OR expr

    RBRACKET        shift and go to state 118
    PLUS            shift and go to state 100
    MINUS           shift and go to state 101
    TIMES           shift and go to state 102
    DIVIDE          shift and go to state 103
    MOD             shift and go to state 104
    LT              shift and go to state 105
    GT              shift and go to state 106
    LE              shift and go to state 107
    GE              shift and go to state 108
    EQ              shift and go to state 109
    NE              shift and go to state 110
    AND             shift and go to state 111
    OR              shift and go to state 112


state 94

    (36) if_stmt -> IF LPAREN expr . RPAREN block elif_part else_part_opt
    (50) expr -> expr . PLUS expr
    (51) expr -> expr . MINUS expr
    (52) expr -> expr . TIMES expr
    (53) expr -> expr . DIVIDE expr
    (54) expr -> expr . MOD expr
    (55) expr -> expr . LT expr
    (56) expr -> expr . GT expr
    (57) expr -> expr . LE expr
    (58) expr -> expr . GE expr
    (59) expr -> expr . EQ expr
    (60) expr -> expr . NE expr
    (61) expr -> expr . AND expr
    (62) expr -> expr . OR expr

    RPAREN          shift and go to state 119
    PLUS            shift and go to state 100
    MINUS           shift and go to state 101
    TIMES           shift and go to state 102
    DIVIDE          shift and go to state 103
    MOD             shift and go to state 104
    LT              shift and go to state 105
    GT              shift and go to state 106
    LE              shift and go to state 107
    GE              shift and go to state 108
    EQ              shift and go to state 109
    NE              shift and go to state 110
    AND             shift and go to state 111
    OR              shift and go to state 112


state 95

    (41) while_stmt -> WHILE LPAREN expr . RPAREN block
    (50) expr -> expr . PLUS expr
    (51) expr -> expr . MINUS expr
    (52) expr -> expr . TIMES expr
    (53) expr -> expr . DIVIDE expr
    (54) expr -> expr . MOD expr
    (55) expr -> expr . LT expr
    (56) expr -> expr . GT expr
    (57) expr -> expr . LE expr
    (58) expr -> expr . GE expr
    (59) expr -> expr . EQ expr
    (60) expr -> expr . NE expr
    (61) expr -> expr . AND expr
    (62) expr -> expr . OR expr

    RPAREN          shift and go to state 120
    PLUS            shift and go to state 100
    MINUS           shift and go to state 101
    TIMES           shift and go to state 102
    DIVIDE          shift and go to state 103
    MOD             shift and go to state 104
    LT              shift and go to state 105
    GT              shift and go to state 106
    LE              shift and go to state 107
    GE              shift and go to state 108
    EQ              shift and go to state 109
    NE              shift and go to state 110
    AND             shift and go to state 111
    OR              shift and go to state 112


state 96

    (42) for_stmt -> FOR LPAREN assignment . SEMI expr SEMI assignment RPAREN block

    SEMI            shift and go to state 121


state 97

    (34) location -> ID .
    (35) location -> ID . LBRACKET expr RBRACKET

    ASSIGN          reduce using rule 34 (location -> ID .)
    LBRACKET        shift and go to state 66


state 98

    (43) io_stmt -> PRINT LPAREN expr . RPAREN
    (50) expr -> expr . PLUS expr
    (51) expr -> expr . MINUS expr
    (52) expr -> expr . TIMES expr
    (53) expr -> expr . DIVIDE expr
    (54) expr -> expr . MOD expr
    (55) expr -> expr . LT expr
    (56) expr -> expr . GT expr
    (57) expr -> expr . LE expr
    (58) expr -> expr . GE expr
    (59) expr -> expr . EQ expr
    (60) expr -> expr . NE expr
    (61) expr -> expr . AND expr
    (62) expr -> expr . OR expr

    RPAREN          shift and go to state 122
    PLUS            shift and go to state 100
    MINUS           shift and go to state 101
    TIMES           shift and go to state 102
    DIVIDE          shift and go to state 103
    MOD             shift and go to state 104
    LT              shift and go to state 105
    GT              shift and go to state 106
    LE              shift and go to state 107
    GE              shift and go to state 108
    EQ              shift and go to state 109
    NE              shift and go to state 110
    AND             shift and go to state 111
    OR              shift and go to state 112


state 99

    (44) io_stmt -> INPUT LPAREN ID . RPAREN

    RPAREN          shift and go to state 123


state 100

    (50) expr -> expr PLUS . expr
    (50) expr -> . expr PLUS expr
    (51) expr -> . expr MINUS expr
    (52) expr -> . expr TIMES expr
    (53) expr -> . expr DIVIDE expr
    (54) expr -> . expr MOD expr
    (55) expr -> . expr LT expr
    (56) expr -> . expr GT expr
    (57) expr -> . expr LE expr
    (58) expr -> . expr GE expr
    (59) expr -> . expr EQ expr
    (60) expr -> . expr NE expr
    (61) expr -> . expr AND expr
    (62) expr -> . expr OR expr
    (63) expr -> . MINUS expr
    (64) expr -> . NOT expr
    (65) expr -> . LPAREN expr RPAREN
    (66) expr -> . literal
    (67) expr -> . location
    (68) expr -> . func_call
    (74) literal -> . INT_LITERAL
    (75) literal -> . FLOAT_LITERAL
    (76) literal -> . CHAR_LITERAL
    (77) literal -> . STRING_LITERAL
    (78) literal -> . TRUE
    (79) literal -> . FALSE
    (34) location -> . ID
    (35) location -> . ID LBRACKET expr RBRACKET
    (69) func_call -> . ID LPAREN arg_list_opt RPAREN

    MINUS           shift and go to state 75
    NOT             shift and go to state 76
    LPAREN          shift and go to state 77
    INT_LITERAL     shift and go to state 81
    FLOAT_LITERAL   shift and go to state 82
    CHAR_LITERAL    shift and go to state 83
    STRING_LITERAL  shift and go to state 84
    TRUE            shift and go to state 85
    FALSE           shift and go to state 86
    ID              shift and go to state 87

    expr                           shift and go to state 124
    literal                        shift and go to state 78
    location                       shift and go to state 79
    func_call                      shift and go to state 80

state 101

    (51) expr -> expr MINUS . expr
    (50) expr -> . expr PLUS expr
    (51) expr -> . expr MINUS expr
    (52) expr -> . expr TIMES expr
    (53) expr -> . expr DIVIDE expr
    (54) expr -> . expr MOD expr
    (55) expr -> . expr LT expr
    (56) expr -> . expr GT expr
    (57) expr -> . expr LE expr
    (58) expr -> . expr GE expr
    (59) expr -> . expr EQ expr
    (60) expr -> . expr NE expr
    (61) expr -> . expr AND expr
    (62) expr -> . expr OR expr
    (63) expr -> . MINUS expr
    (64) expr -> . NOT expr
    (65) expr -> . LPAREN expr RPAREN
    (66) expr -> . literal
    (67) expr -> . location
    (68) expr -> . func_call
    (74) literal -> . INT_LITERAL
    (75) literal -> . FLOAT_LITERAL
    (76) literal -> . CHAR_LITERAL
    (77) literal -> . STRING_LITERAL
    (78) literal -> . TRUE
    (79) literal -> . FALSE
    (34) location -> . ID
    (35) location -> . ID LBRACKET expr RBRACKET
    (69) func_call -> . ID LPAREN arg_list_opt RPAREN

    MINUS           shift and go to state 75
    NOT             shift and go to state 76
    LPAREN          shift and go to state 77
    INT_LITERAL     shift and go to state 81
    FLOAT_LITERAL   shift and go to state 82
    CHAR_LITERAL    shift and go to state 83
    STRING_LITERAL  shift and go to state 84
    TRUE            shift and go to state 85
    FALSE           shift and go to state 86
    ID              shift and go to state 87

    expr                           shift and go to state 125
    literal                        shift and go to state 78
    location                       shift and go to state 79
    func_call                      shift and go to state 80

state 102

    (52) expr -> expr TIMES . expr
    (50) expr -> . expr PLUS expr
    (51) expr -> . expr MINUS expr
    (52) expr -> . expr TIMES expr
    (53) expr -> . expr DIVIDE expr
    (54) expr -> . expr MOD expr
    (55) expr -> . expr LT expr
    (56) expr -> . expr GT expr
    (57) expr -> . expr LE expr
    (58) expr -> . expr GE expr
    (59) expr -> . expr EQ expr
    (60) expr -> . expr NE expr
    (61) expr -> . expr AND expr
    (62) expr -> . expr OR expr
    (63) expr -> . MINUS expr
    (64) expr -> . NOT expr
    (65) expr -> . LPAREN expr RPAREN
    (66) expr -> . literal
    (67) expr -> . location
    (68) expr -> . func_call
    (74) literal -> . INT_LITERAL
    (75) literal -> . FLOAT_LITERAL
    (76) literal -> . CHAR_LITERAL
    (77) literal -> . STRING_LITERAL
    (78) literal -> . TRUE
    (79) literal -> . FALSE
    (34) location -> . ID
    (35) location -> . ID LBRACKET expr RBRACKET
    (69) func_call -> . ID LPAREN arg_list_opt RPAREN

    MINUS           shift and go to state 75
    NOT             shift and go to state 76
    LPAREN          shift and go to state 77
    INT_LITERAL     shift and go to state 81
    FLOAT_LITERAL   shift and go to state 82
    CHAR_LITERAL    shift and go to state 83
    STRING_LITERAL  shift and go to state 84
    TRUE            shift and go to state 85
    FALSE           shift and go to state 86
    ID              shift and go to state 87

    expr                           shift and go to state 126
    literal                        shift and go to state 78
    location                       shift and go to state 79
    func_call                      shift and go to state 80

state 103

    (53) expr -> expr DIVIDE . expr
    (50) expr -> . expr PLUS expr
    (51) expr -> . expr MINUS expr
    (52) expr -> . expr TIMES expr
    (53) expr -> . expr DIVIDE expr
    (54) expr -> . expr MOD expr
    (55) expr -> . expr LT expr
    (56) expr -> . expr GT expr
    (57) expr -> . expr LE expr
    (58) expr -> . expr GE expr
    (59) expr -> . expr EQ expr
    (60) expr -> . expr NE expr
    (61) expr -> . expr AND expr
    (62) expr -> . expr OR expr
    (63) expr -> . MINUS expr
    (64) expr -> . NOT expr
    (65) expr -> . LPAREN expr RPAREN
    (66) expr -> . literal
    (67) expr -> . location
    (68) expr -> . func_call
    (74) literal -> . INT_LITERAL
    (75) literal -> . FLOAT_LITERAL
    (76) literal -> . CHAR_LITERAL
    (77) literal -> . STRING_LITERAL
    (78) literal -> . TRUE
    (79) literal -> . FALSE
    (34) location -> . ID
    (35) location -> . ID LBRACKET expr RBRACKET
    (69) func_call -> . ID LPAREN arg_list_opt RPAREN

    MINUS           shift and go to state 75
    NOT             shift and go to state 76
    LPAREN          shift and go to state 77
    INT_LITERAL     shift and go to state 81
    FLOAT_LITERAL   shift and go to state 82
    CHAR_LITERAL    shift and go to state 83
    STRING_LITERAL  shift and go to state 84
    TRUE            shift and go to state 85
    FALSE           shift and go to state 86
    ID              shift and go to state 87

    expr                           shift and go to state 127
    literal                        shift and go to state 78
    location                       shift and go to state 79
    func_call                      shift and go to state 80

state 104

    (54) expr -> expr MOD . expr
    (50) expr -> . expr PLUS expr
    (51) expr -> . expr MINUS expr
    (52) expr -> . expr TIMES expr
    (53) expr -> . expr DIVIDE expr
    (54) expr -> . expr MOD expr
    (55) expr -> . expr LT expr
    (56) expr -> . expr GT expr
    (57) expr -> . expr LE expr
    (58) expr -> . expr GE expr
    (59) expr -> . expr EQ expr
    (60) expr -> . expr NE expr
    (61) expr -> . expr AND expr
    (62) expr -> . expr OR expr
    (63) expr -> . MINUS expr
    (64) expr -> . NOT expr
    (65) expr -> . LPAREN expr RPAREN
    (66) expr -> . literal
    (67) expr -> . location
    (68) expr -> . func_call
    (74) literal -> . INT_LITERAL
    (75) literal -> . FLOAT_LITERAL
    (76) literal -> . CHAR_LITERAL
    (77) literal -> . STRING_LITERAL
    (78) literal -> . TRUE
    (79) literal -> . FALSE
    (34) location -> . ID
    (35) location -> . ID LBRACKET expr RBRACKET
    (69) func_call -> . ID LPAREN arg_list_opt RPAREN

    MINUS           shift and go to state 75
    NOT             shift and go to state 76
    LPAREN          shift and go to state 77
    INT_LITERAL     shift and go to state 81
    FLOAT_LITERAL   shift and go to state 82
    CHAR_LITERAL    shift and go to state 83
    STRING_LITERAL  shift and go to state 84
    TRUE            shift and go to state 85
    FALSE           shift and go to state 86
    ID              shift and go to state 87

    expr                           shift and go to state 128
    literal                        shift and go to state 78
    location                       shift and go to state 79
    func_call                      shift and go to state 80

state 105

    (55) expr -> expr LT . expr
    (50) expr -> . expr PLUS expr
    (51) expr -> . expr MINUS expr
    (52) expr -> . expr TIMES expr
    (53) expr -> . expr DIVIDE expr
    (54) expr -> . expr MOD expr
    (55) expr -> . expr LT expr
    (56) expr -> . expr GT expr
    (57) expr -> . expr LE expr
    (58) expr -> . expr GE expr
    (59) expr -> . expr EQ expr
    (60) expr -> . expr NE expr
    (61) expr -> . expr AND expr
    (62) expr -> . expr OR expr
    (63) expr -> . MINUS expr
    (64) expr -> . NOT expr
    (65) expr -> . LPAREN expr RPAREN
    (66) expr -> . literal
    (67) expr -> . location
    (68) expr -> . func_call
    (74) literal -> . INT_LITERAL
    (75) literal -> . FLOAT_LITERAL
    (76) literal -> . CHAR_LITERAL
    (77) literal -> . STRING_LITERAL
    (78) literal -> . TRUE
    (79) literal -> . FALSE
    (34) location -> . ID
    (35) location -> . ID LBRACKET expr RBRACKET
    (69) func_call -> . ID LPAREN arg_list_opt RPAREN

    MINUS           shift and go to state 75
    NOT             shift and go to state 76
    LPAREN          shift and go to state 77
    INT_LITERAL     shift and go to state 81
    FLOAT_LITERAL   shift and go to state 82
    CHAR_LITERAL    shift and go to state 83
    STRING_LITERAL  shift and go to state 84
    TRUE            shift and go to state 85
    FALSE           shift and go to state 86
    ID              shift and go to state 87

    expr                           shift and go to state 129
    literal                        shift and go to state 78
    location                       shift and go to state 79
    func_call                      shift and go to state 80

state 106

    (56) expr -> expr GT . expr
    (50) expr -> . expr PLUS expr
    (51) expr -> . expr MINUS expr
    (52) expr -> . expr TIMES expr
    (53) expr -> . expr DIVIDE expr
    (54) expr -> . expr MOD expr
    (55) expr -> . expr LT expr
    (56) expr -> . expr GT expr
    (57) expr -> . expr LE expr
    (58) expr -> . expr GE expr
    (59) expr -> . expr EQ expr
    (60) expr -> . expr NE expr
    (61) expr -> . expr AND expr
    (62) expr -> . expr OR expr
    (63) expr -> . MINUS expr
    (64) expr -> . NOT expr
    (65) expr -> . LPAREN expr RPAREN
    (66) expr -> . literal
    (67) expr -> . location
    (68) expr -> . func_call
    (74) literal -> . INT_LITERAL
    (75) literal -> . FLOAT_LITERAL
    (76) literal -> . CHAR_LITERAL
    (77) literal -> . STRING_LITERAL
    (78) literal -> . TRUE
    (79) literal -> . FALSE
    (34) location -> . ID
    (35) location -> . ID LBRACKET expr RBRACKET
    (69) func_call -> . ID LPAREN arg_list_opt RPAREN

    MINUS           shift and go to state 75
    NOT             shift and go to state 76
    LPAREN          shift and go to state 77
    INT_LITERAL     shift and go to state 81
    FLOAT_LITERAL   shift and go to state 82
    CHAR_LITERAL    shift and go to state 83
    STRING_LITERAL  shift and go to state 84
    TRUE            shift and go to state 85
    FALSE           shift and go to state 86
    ID              shift and go to state 87

    expr                           shift and go to state 130
    literal                        shift and go to state 78
    location                       shift and go to state 79
    func_call                      shift and go to state 80

state 107

    (57) expr -> expr LE . expr
    (50) expr -> . expr PLUS expr
    (51) expr -> . expr MINUS expr
    (52) expr -> . expr TIMES expr
    (53) expr -> . expr DIVIDE expr
    (54) expr -> . expr MOD expr
    (55) expr -> . expr LT expr
    (56) expr -> . expr GT expr
    (57) expr -> . expr LE expr
    (58) expr -> . expr GE expr
    (59) expr -> . expr EQ expr
    (60) expr -> . expr NE expr
    (61) expr -> . expr AND expr
    (62) expr -> . expr OR expr
    (63) expr -> . MINUS expr
    (64) expr -> . NOT expr
    (65) expr -> . LPAREN expr RPAREN
    (66) expr -> . literal
    (67) expr -> . location
    (68) expr -> . func_call
    (74) literal -> . INT_LITERAL
    (75) literal -> . FLOAT_LITERAL
    (76) literal -> . CHAR_LITERAL
    (77) literal -> . STRING_LITERAL
    (78) literal -> . TRUE
    (79) literal -> . FALSE
    (34) location -> . ID
    (35) location -> . ID LBRACKET expr RBRACKET
    (69) func_call -> . ID LPAREN arg_list_opt RPAREN

    MINUS           shift and go to state 75
    NOT             shift and go to state 76
    LPAREN          shift and go to state 77
    INT_LITERAL     shift and go to state 81
    FLOAT_LITERAL   shift and go to state 82
    CHAR_LITERAL    shift and go to state 83
    STRING_LITERAL  shift and go to state 84
    TRUE            shift and go to state 85
    FALSE           shift and go to state 86
    ID              shift and go to state 87

    expr                           shift and go to state 131
    literal                        shift and go to state 78
    location                       shift and go to state 79
    func_call                      shift and go to state 80

state 108

    (58) expr -> expr GE . expr
    (50) expr -> . expr PLUS expr
    (51) expr -> . expr MINUS expr
    (52) expr -> . expr TIMES expr
    (53) expr -> . expr DIVIDE expr
    (54) expr -> . expr MOD expr
    (55) expr -> . expr LT expr
    (56) expr -> . expr GT expr
    (57) expr -> . expr LE expr
    (58) expr -> . expr GE expr
    (59) expr -> . expr EQ expr
    (60) expr -> . expr NE expr
    (61) expr -> . expr AND expr
    (62) expr -> . expr OR expr
    (63) expr -> . MINUS expr
    (64) expr -> . NOT expr
    (65) expr -> . LPAREN expr RPAREN
    (66) expr -> . literal
    (67) expr -> . location
    (68) expr -> . func_call
    (74) literal -> . INT_LITERAL
    (75) literal -> . FLOAT_LITERAL
    (76) literal -> . CHAR_LITERAL
    (77) literal -> . STRING_LITERAL
    (78) literal -> . TRUE
    (79) literal -> . FALSE
    (34) location -> . ID
    (35) location -> . ID LBRACKET expr RBRACKET
    (69) func_call -> . ID LPAREN arg_list_opt RPAREN

    MINUS           shift and go to state 75
    NOT             shift and go to state 76
    LPAREN          shift and go to state 77
    INT_LITERAL     shift and go to state 81
    FLOAT_LITERAL   shift and go to state 82
    CHAR_LITERAL    shift and go to state 83
    STRING_LITERAL  shift and go to state 84
    TRUE            shift and go to state 85
    FALSE           shift and go to state 86
    ID              shift and go to state 87

    expr                           shift and go to state 132
    literal                        shift and go to state 78
    location                       shift and go to state 79
    func_call                      shift and go to state 80

state 109

    (59) expr -> expr EQ . expr
    (50) expr -> . expr PLUS expr
    (51) expr -> . expr MINUS expr
    (52) expr -> . expr TIMES expr
    (53) expr -> . expr DIVIDE expr
    (54) expr -> . expr MOD expr
    (55) expr -> . expr LT expr
    (56) expr -> . expr GT expr
    (57) expr -> . expr LE expr
    (58) expr -> . expr GE expr
    (59) expr -> . expr EQ expr
    (60) expr -> . expr NE expr
    (61) expr -> . expr AND expr
    (62) expr -> . expr OR expr
    (63) expr -> . MINUS expr
    (64) expr -> . NOT expr
    (65) expr -> . LPAREN expr RPAREN
    (66) expr -> . literal
    (67) expr -> . location
    (68) expr -> . func_call
    (74) literal -> . INT_LITERAL
    (75) literal -> . FLOAT_LITERAL
    (76) literal -> . CHAR_LITERAL
    (77) literal -> . STRING_LITERAL
    (78) literal -> . TRUE
    (79) literal -> . FALSE
    (34) location -> . ID
    (35) location -> . ID LBRACKET expr RBRACKET
    (69) func_call -> . ID LPAREN arg_list_opt RPAREN

    MINUS           shift and go to state 75
    NOT             shift and go to state 76
    LPAREN          shift and go to state 77
    INT_LITERAL     shift and go to state 81
    FLOAT_LITERAL   shift and go to state 82
    CHAR_LITERAL    shift and go to state 83
    STRING_LITERAL  shift and go to state 84
    TRUE            shift and go to state 85
    FALSE           shift and go to state 86
    ID              shift and go to state 87

    expr                           shift and go to state 133
    literal                        shift and go to state 78
    location                       shift and go to state 79
    func_call                      shift and go to state 80

state 110

    (60) expr -> expr NE . expr
    (50) expr -> . expr PLUS expr
    (51) expr -> . expr MINUS expr
    (52) expr -> . expr TIMES expr
    (53) expr -> . expr DIVIDE expr
    (54) expr -> . expr MOD expr
    (55) expr -> . expr LT expr
    (56) expr -> . expr GT expr
    (57) expr -> . expr LE expr
    (58) expr -> . expr GE expr
    (59) expr -> . expr EQ expr
    (60) expr -> . expr NE expr
    (61) expr -> . expr AND expr
    (62) expr -> . expr OR expr
    (63) expr -> . MINUS expr
    (64) expr -> . NOT expr
    (65) expr -> . LPAREN expr RPAREN
    (66) expr -> . literal
    (67) expr -> . location
    (68) expr -> . func_call
    (74) literal -> . INT_LITERAL
    (75) literal -> . FLOAT_LITERAL
    (76) literal -> . CHAR_LITERAL
    (77) literal -> . STRING_LITERAL
    (78) literal -> . TRUE
    (79) literal -> . FALSE
    (34) location -> . ID
    (35) location -> . ID LBRACKET expr RBRACKET
    (69) func_call -> . ID LPAREN arg_list_opt RPAREN

    MINUS           shift and go to state 75
    NOT             shift and go to state 76
    LPAREN          shift and go to state 77
    INT_LITERAL     shift and go to state 81
    FLOAT_LITERAL   shift and go to state 82
    CHAR_LITERAL    shift and go to state 83
    STRING_LITERAL  shift and go to state 84
    TRUE            shift and go to state 85
    FALSE           shift and go to state 86
    ID              shift and go to state 87

    expr                           shift and go to state 134
    literal                        shift and go to state 78
    location                       shift and go to state 79
    func_call                      shift and go to state 80

state 111

    (61) expr -> expr AND . expr
    (50) expr -> . expr PLUS expr
    (51) expr -> . expr MINUS expr
    (52) expr -> . expr TIMES expr
    (53) expr -> . expr DIVIDE expr
    (54) expr -> . expr MOD expr
    (55) expr -> . expr LT expr
    (56) expr -> . expr GT expr
    (57) expr -> . expr LE expr
    (58) expr -> . expr GE expr
    (59) expr -> . expr EQ expr
    (60) expr -> . expr NE expr
    (61) expr -> . expr AND expr
    (62) expr -> . expr OR expr
    (63) expr -> . MINUS expr
    (64) expr -> . NOT expr
    (65) expr -> . LPAREN expr RPAREN
    (66) expr -> . literal
    (67) expr -> . location
    (68) expr -> . func_call
    (74) literal -> . INT_LITERAL
    (75) literal -> . FLOAT_LITERAL
    (76) literal -> . CHAR_LITERAL
    (77) literal -> . STRING_LITERAL
    (78) literal -> . TRUE
    (79) literal -> . FALSE
    (34) location -> . ID
    (35) location -> . ID LBRACKET expr RBRACKET
    (69) func_call -> . ID LPAREN arg_list_opt RPAREN

    MINUS           shift and go to state 75
    NOT             shift and go to state 76
    LPAREN          shift and go to state 77
    INT_LITERAL     shift and go to state 81
    FLOAT_LITERAL   shift and go to state 82
    CHAR_LITERAL    shift and go to state 83
    STRING_LITERAL  shift and go to state 84
    TRUE            shift and go to state 85
    FALSE           shift and go to state 86
    ID              shift and go to state 87

    expr                           shift and go to state 135
    literal                        shift and go to state 78
    location                       shift and go to state 79
    func_call                      shift and go to state 80

state 112

    (62) expr -> expr OR . expr
    (50) expr -> . expr PLUS expr
    (51) expr -> . expr MINUS expr
    (52) expr -> . expr TIMES expr
    (53) expr -> . expr DIVIDE expr
    (54) expr -> . expr MOD expr
    (55) expr -> . expr LT expr
    (56) expr -> . expr GT expr
    (57) expr -> . expr LE expr
    (58) expr -> . expr GE expr
    (59) expr -> . expr EQ expr
    (60) expr -> . expr NE expr
    (61) expr -> . expr AND expr
    (62) expr -> . expr OR expr
    (63) expr -> . MINUS expr
    (64) expr -> . NOT expr
    (65) expr -> . LPAREN expr RPAREN
    (66) expr -> . literal
    (67) expr -> . location
    (68) expr -> . func_call
    (74) literal -> . INT_LITERAL
    (75) literal -> . FLOAT_LITERAL
    (76) literal -> . CHAR_LITERAL
    (77) literal -> . STRING_LITERAL
    (78) literal -> . TRUE
    (79) literal -> . FALSE
    (34) location -> . ID
    (35) location -> . ID LBRACKET expr RBRACKET
    (69) func_call -> . ID LPAREN arg_list_opt RPAREN

    MINUS           shift and go to state 75
    NOT             shift and go to state 76
    LPAREN          shift and go to state 77
    INT_LITERAL     shift and go to state 81
    FLOAT_LITERAL   shift and go to state 82
    CHAR_LITERAL    shift and go to state 83
    STRING_LITERAL  shift and go to state 84
    TRUE            shift and go to state 85
    FALSE           shift and go to state 86
    ID              shift and go to state 87

    expr                           shift and go to state 136
    literal                        shift and go to state 78
    location                       shift and go to state 79
    func_call                      shift and go to state 80

state 113

    (63) expr -> MINUS expr .
    (50) expr -> expr . PLUS expr
    (51) expr -> expr . MINUS expr
    (52) expr -> expr . TIMES expr
    (53) expr -> expr . DIVIDE expr
    (54) expr -> expr . MOD expr
    (55) expr -> expr . LT expr
    (56) expr -> expr . GT expr
    (57) expr -> expr . LE expr
    (58) expr -> expr . GE expr
    (59) expr -> expr . EQ expr
    (60) expr -> expr . NE expr
    (61) expr -> expr . AND expr
    (62) expr -> expr . OR expr

    PLUS            reduce using rule 63 (expr -> MINUS expr .)
    MINUS           reduce using rule 63 (expr -> MINUS expr .)
    TIMES           reduce using rule 63 (expr -> MINUS expr .)
    DIVIDE          reduce using rule 63 (expr -> MINUS expr .)
    MOD             reduce using rule 63 (expr -> MINUS expr .)
    LT              reduce using rule 63 (expr -> MINUS expr .)
    GT              reduce using rule 63 (expr -> MINUS expr .)
    LE              reduce using rule 63 (expr -> MINUS expr .)
    GE              reduce using rule 63 (expr -> MINUS expr .)
    EQ              reduce using rule 63 (expr -> MINUS expr .)
    NE              reduce using rule 63 (expr -> MINUS expr .)
    AND             reduce using rule 63 (expr -> MINUS expr .)
    OR              reduce using rule 63 (expr -> MINUS expr .)
    SEMI            reduce using rule 63 (expr -> MINUS expr .)
    RPAREN          reduce using rule 63 (expr -> MINUS expr .)
    COMMA           reduce using rule 63 (expr -> MINUS expr .)
    RBRACKET        reduce using rule 63 (expr -> MINUS expr .)

  ! PLUS            [ shift and go to state 100 ]
  ! MINUS           [ shift and go to state 101 ]
  ! TIMES           [ shift and go to state 102 ]
  ! DIVIDE          [ shift and go to state 103 ]
  ! MOD             [ shift and go to state 104 ]
  ! LT              [ shift and go to state 105 ]
  ! GT              [ shift and go to state 106 ]
  ! LE              [ shift and go to state 107 ]
  ! GE              [ shift and go to state 108 ]
  ! EQ              [ shift and go to state 109 ]
  ! NE              [ shift and go to state 110 ]
  ! AND             [ shift and go to state 111 ]
  ! OR              [ shift and go to state 112 ]


state 114

    (64) expr -> NOT expr .
    (50) expr -> expr . PLUS expr
    (51) expr -> expr . MINUS expr
    (52) expr -> expr . TIMES expr
    (53) expr -> expr . DIVIDE expr
    (54) expr -> expr . MOD expr
    (55) expr -> expr . LT expr
    (56) expr -> expr . GT expr
    (57) expr -> expr . LE expr
    (58) expr -> expr . GE expr
    (59) expr -> expr . EQ expr
    (60) expr -> expr . NE expr
    (61) expr -> expr . AND expr
    (62) expr -> expr . OR expr

    PLUS            reduce using rule 64 (expr -> NOT expr .)
    MINUS           reduce using rule 64 (expr -> NOT expr .)
    TIMES           reduce using rule 64 (expr -> NOT expr .)
    DIVIDE          reduce using rule 64 (expr -> NOT expr .)
    MOD             reduce using rule 64 (expr -> NOT expr .)
    LT              reduce using rule 64 (expr -> NOT expr .)
    GT              reduce using rule 64 (expr -> NOT expr .)
    LE              reduce using rule 64 (expr -> NOT expr .)
    GE              reduce using rule 64 (expr -> NOT expr .)
    EQ              reduce using rule 64 (expr -> NOT expr .)
    NE              reduce using rule 64 (expr -> NOT expr .)
    AND             reduce using rule 64 (expr -> NOT expr .)
    OR              reduce using rule 64 (expr -> NOT expr .)
    SEMI            reduce using rule 64 (expr -> NOT expr .)
    RPAREN          reduce using rule 64 (expr -> NOT expr .)
    COMMA           reduce using rule 64 (expr -> NOT expr .)
    RBRACKET        reduce using rule 64 (expr -> NOT expr .)

  ! PLUS            [ shift and go to state 100 ]
  ! MINUS           [ shift and go to state 101 ]
  ! TIMES           [ shift and go to state 102 ]
  ! DIVIDE          [ shift and go to state 103 ]
  ! MOD             [ shift and go to state 104 ]
  ! LT              [ shift and go to state 105 ]
  ! GT              [ shift and go to state 106 ]
  ! LE              [ shift and go to state 107 ]
  ! GE              [ shift and go to state 108 ]
  ! EQ              [ shift and go to state 109 ]
  ! NE              [ shift and go to state 110 ]
  ! AND             [ shift and go to state 111 ]
  ! OR              [ shift and go to state 112 ]


state 115

    (65) expr -> LPAREN expr . RPAREN
    (50) expr -> expr . PLUS expr
    (51) expr -> expr . MINUS expr
    (52) expr -> expr . TIMES expr
    (53) expr -> expr . DIVIDE expr
    (54) expr -> expr . MOD expr
    (55) expr -> expr . LT expr
    (56) expr -> expr . GT expr
    (57) expr -> expr . LE expr
    (58) expr -> expr . GE expr
    (59) expr -> expr . EQ expr
    (60) expr -> expr . NE expr
    (61) expr -> expr . AND expr
    (62) expr -> expr . OR expr

    RPAREN          shift and go to state 137
    PLUS            shift and go to state 100
    MINUS           shift and go to state 101
    TIMES           shift and go to state 102
    DIVIDE          shift and go to state 103
    MOD             shift and go to state 104
    LT              shift and go to state 105
    GT              shift and go to state 106
    LE              shift and go to state 107
    GE              shift and go to state 108
    EQ              shift and go to state 109
    NE              shift and go to state 110
    AND             shift and go to state 111
    OR              shift and go to state 112


state 116

    (69) func_call -> ID LPAREN arg_list_opt RPAREN .

    SEMI            reduce using rule 69 (func_call -> ID LPAREN arg_list_opt RPAREN .)
    PLUS            reduce using rule 69 (func_call -> ID LPAREN arg_list_opt RPAREN .)
    MINUS           reduce using rule 69 (func_call -> ID LPAREN arg_list_opt RPAREN .)
    TIMES           reduce using rule 69 (func_call -> ID LPAREN arg_list_opt RPAREN .)
    DIVIDE          reduce using rule 69 (func_call -> ID LPAREN arg_list_opt RPAREN .)
    MOD             reduce using rule 69 (func_call -> ID LPAREN arg_list_opt RPAREN .)
    LT              reduce using rule 69 (func_call -> ID LPAREN arg_list_opt RPAREN .)
    GT              reduce using rule 69 (func_call -> ID LPAREN arg_list_opt RPAREN .)
    LE              reduce using rule 69 (func_call -> ID LPAREN arg_list_opt RPAREN .)
    GE              reduce using rule 69 (func_call -> ID LPAREN arg_list_opt RPAREN .)
    EQ              reduce using rule 69 (func_call -> ID LPAREN arg_list_opt RPAREN .)
    NE              reduce using rule 69 (func_call -> ID LPAREN arg_list_opt RPAREN .)
    AND             reduce using rule 69 (func_call -> ID LPAREN arg_list_opt RPAREN .)
    OR              reduce using rule 69 (func_call -> ID LPAREN arg_list_opt RPAREN .)
    RPAREN          reduce using rule 69 (func_call -> ID LPAREN arg_list_opt RPAREN .)
    COMMA           reduce using rule 69 (func_call -> ID LPAREN arg_list_opt RPAREN .)
    RBRACKET        reduce using rule 69 (func_call -> ID LPAREN arg_list_opt RPAREN .)


state 117

    (72) arg_list -> arg_list COMMA . expr
    (50) expr -> . expr PLUS expr
    (51) expr -> . expr MINUS expr
    (52) expr -> . expr TIMES expr
    (53) expr -> . expr DIVIDE expr
    (54) expr -> . expr MOD expr
    (55) expr -> . expr LT expr
    (56) expr -> . expr GT expr
    (57) expr -> . expr LE expr
    (58) expr -> . expr GE expr
    (59) expr -> . expr EQ expr
    (60) expr -> . expr NE expr
    (61) expr -> . expr AND expr
    (62) expr -> . expr OR expr
    (63) expr -> . MINUS expr
    (64) expr -> . NOT expr
    (65) expr -> . LPAREN expr RPAREN
    (66) expr -> . literal
    (67) expr -> . location
    (68) expr -> . func_call
    (74) literal -> . INT_LITERAL
    (75) literal -> . FLOAT_LITERAL
    (76) literal -> . CHAR_LITERAL
    (77) literal -> . STRING_LITERAL
    (78) literal -> . TRUE
    (79) literal -> . FALSE
    (34) location -> . ID
    (35) location -> . ID LBRACKET expr RBRACKET
    (69) func_call -> . ID LPAREN arg_list_opt RPAREN

    MINUS           shift and go to state 75
    NOT             shift and go to state 76
    LPAREN          shift and go to state 77
    INT_LITERAL     shift and go to state 81
    FLOAT_LITERAL   shift and go to state 82
    CHAR_LITERAL    shift and go to state 83
    STRING_LITERAL  shift and go to state 84
    TRUE            shift and go to state 85
    FALSE           shift and go to state 86
    ID              shift and go to state 87

    expr                           shift and go to state 138
    literal                        shift and go to state 78
    location                       shift and go to state 79
    func_call                      shift and go to state 80

state 118

    (35) location -> ID LBRACKET expr RBRACKET .

    ASSIGN          reduce using rule 35 (location -> ID LBRACKET expr RBRACKET .)
    PLUS            reduce using rule 35 (location -> ID LBRACKET expr RBRACKET .)
    MINUS           reduce using rule 35 (location -> ID LBRACKET expr RBRACKET .)
    TIMES           reduce using rule 35 (location -> ID LBRACKET expr RBRACKET .)
    DIVIDE          reduce using rule 35 (location -> ID LBRACKET expr RBRACKET .)
    MOD             reduce using rule 35 (location -> ID LBRACKET expr RBRACKET .)
    LT              reduce using rule 35 (location -> ID LBRACKET expr RBRACKET .)
    GT              reduce using rule 35 (location -> ID LBRACKET expr RBRACKET .)
    LE              reduce using rule 35 (location -> ID LBRACKET expr RBRACKET .)
    GE              reduce using rule 35 (location -> ID LBRACKET expr RBRACKET .)
    EQ              reduce using rule 35 (location -> ID LBRACKET expr RBRACKET .)
    NE              reduce using rule 35 (location -> ID LBRACKET expr RBRACKET .)
    AND             reduce using rule 35 (location -> ID LBRACKET expr RBRACKET .)
    OR              reduce using rule 35 (location -> ID LBRACKET expr RBRACKET .)
    SEMI            reduce using rule 35 (location -> ID LBRACKET expr RBRACKET .)
    RPAREN          reduce using rule 35 (location -> ID LBRACKET expr RBRACKET .)
    COMMA           reduce using rule 35 (location -> ID LBRACKET expr RBRACKET .)
    RBRACKET        reduce using rule 35 (location -> ID LBRACKET expr RBRACKET .)


state 119

    (36) if_stmt -> IF LPAREN expr RPAREN . block elif_part else_part_opt
    (19) block -> . LBRACE statement_list RBRACE

    LBRACE          shift and go to state 31

    block                          shift and go to state 139

state 120

    (41) while_stmt -> WHILE LPAREN expr RPAREN . block
    (19) block -> . LBRACE statement_list RBRACE

    LBRACE          shift and go to state 31

    block                          shift and go to state 140

state 121

    (42) for_stmt -> FOR LPAREN assignment SEMI . expr SEMI assignment RPAREN block
    (50) expr -> . expr PLUS expr
    (51) expr -> . expr MINUS expr
    (52) expr -> . expr TIMES expr
    (53) expr -> . expr DIVIDE expr
    (54) expr -> . expr MOD expr
    (55) expr -> . expr LT expr
    (56) expr -> . expr GT expr
    (57) expr -> . expr LE expr
    (58) expr -> . expr GE expr
    (59) expr -> . expr EQ expr
    (60) expr -> . expr NE expr
    (61) expr -> . expr AND expr
    (62) expr -> . expr OR expr
    (63) expr -> . MINUS expr
    (64) expr -> . NOT expr
    (65) expr -> . LPAREN expr RPAREN
    (66) expr -> . literal
    (67) expr -> . location
    (68) expr -> . func_call
    (74) literal -> . INT_LITERAL
    (75) literal -> . FLOAT_LITERAL
    (76) literal -> . CHAR_LITERAL
    (77) literal -> . STRING_LITERAL
    (78) literal -> . TRUE
    (79) literal -> . FALSE
    (34) location -> . ID
    (35) location -> . ID LBRACKET expr RBRACKET
    (69) func_call -> . ID LPAREN arg_list_opt RPAREN

    MINUS           shift and go to state 75
    NOT             shift and go to state 76
    LPAREN          shift and go to state 77
    INT_LITERAL     shift and go to state 81
    FLOAT_LITERAL   shift and go to state 82
    CHAR_LITERAL    shift and go to state 83
    STRING_LITERAL  shift and go to state 84
    TRUE            shift and go to state 85
    FALSE           shift and go to state 86
    ID              shift and go to state 87

    expr                           shift and go to state 141
    literal                        shift and go to state 78
    location                       shift and go to state 79
    func_call                      shift and go to state 80

state 122

    (43) io_stmt -> PRINT LPAREN expr RPAREN .

    SEMI            reduce using rule 43 (io_stmt -> PRINT LPAREN expr RPAREN .)


state 123

    (44) io_stmt -> INPUT LPAREN ID RPAREN .

    SEMI            reduce using rule 44 (io_stmt -> INPUT LPAREN ID RPAREN .)


state 124

    (50) expr -> expr PLUS expr .
    (50) expr -> expr . PLUS expr
    (51) expr -> expr . MINUS expr
    (52) expr -> expr . TIMES expr
    (53) expr -> expr . DIVIDE expr
    (54) expr -> expr . MOD expr
    (55) expr -> expr . LT expr
    (56) expr -> expr . GT expr
    (57) expr -> expr . LE expr
    (58) expr -> expr . GE expr
    (59) expr -> expr . EQ expr
    (60) expr -> expr . NE expr
    (61) expr -> expr . AND expr
    (62) expr -> expr . OR expr

    PLUS            reduce using rule 50 (expr -> expr PLUS expr .)
    MINUS           reduce using rule 50 (expr -> expr PLUS expr .)
    LT              reduce using rule 50 (expr -> expr PLUS expr .)
    GT              reduce using rule 50 (expr -> expr PLUS expr .)
    LE              reduce using rule 50 (expr -> expr PLUS expr .)
    GE              reduce using rule 50 (expr -> expr PLUS expr .)
    EQ              reduce using rule 50 (expr -> expr PLUS expr .)
    NE              reduce using rule 50 (expr -> expr PLUS expr .)
    AND             reduce using rule 50 (expr -> expr PLUS expr .)
    OR              reduce using rule 50 (expr -> expr PLUS expr .)
    SEMI            reduce using rule 50 (expr -> expr PLUS expr .)
    RPAREN          reduce using rule 50 (expr -> expr PLUS expr .)
    COMMA           reduce using rule 50 (expr -> expr PLUS expr .)
    RBRACKET        reduce using rule 50 (expr -> expr PLUS expr .)
    TIMES           shift and go to state 102
    DIVIDE          shift and go to state 103
    MOD             shift and go to state 104

  ! TIMES           [ reduce using rule 50 (expr -> expr PLUS expr .) ]
  ! DIVIDE          [ reduce using rule 50 (expr -> expr PLUS expr .) ]
  ! MOD             [ reduce using rule 50 (expr -> expr PLUS expr .) ]
  ! PLUS            [ shift and go to state 100 ]
  ! MINUS           [ shift and go to state 101 ]
  ! LT              [ shift and go to state 105 ]
  ! GT              [ shift and go to state 106 ]
  ! LE              [ shift and go to state 107 ]
  ! GE              [ shift and go to state 108 ]
  ! EQ              [ shift and go to state 109 ]
  ! NE              [ shift and go to state 110 ]
  ! AND             [ shift and go to state 111 ]
  ! OR              [ shift and go to state 112 ]


state 125

    (51) expr -> expr MINUS expr .
    (50) expr -> expr . PLUS expr
    (51) expr -> expr . MINUS expr
    (52) expr -> expr . TIMES expr
    (53) expr -> expr . DIVIDE expr
    (54) expr -> expr . MOD expr
    (55) expr -> expr . LT expr
    (56) expr -> expr . GT expr
    (57) expr -> expr . LE expr
    (58) expr -> expr . GE expr
    (59) expr -> expr . EQ expr
    (60) expr -> expr . NE expr
    (61) expr -> expr . AND expr
    (62) expr -> expr . OR expr

    PLUS            reduce using rule 51 (expr -> expr MINUS expr .)
    MINUS           reduce using rule 51 (expr -> expr MINUS expr .)
    LT              reduce using rule 51 (expr -> expr MINUS expr .)
    GT              reduce using rule 51 (expr -> expr MINUS expr .)
    LE              reduce using rule 51 (expr -> expr MINUS expr .)
    GE              reduce using rule 51 (expr -> expr MINUS expr .)
    EQ              reduce using rule 51 (expr -> expr MINUS expr .)
    NE              reduce using rule 51 (expr -> expr MINUS expr .)
    AND             reduce using rule 51 (expr -> expr MINUS expr .)
    OR              reduce using rule 51 (expr -> expr MINUS expr .)
    SEMI            reduce using rule 51 (expr -> expr MINUS expr .)
    RPAREN          reduce using rule 51 (expr -> expr MINUS expr .)
    COMMA           reduce using rule 51 (expr -> expr MINUS expr .)
    RBRACKET        reduce using rule 51 (expr -> expr MINUS expr .)
    TIMES           shift and go to state 102
    DIVIDE          shift and go to state 103
    MOD             shift and go to state 104

  ! TIMES           [ reduce using rule 51 (expr -> expr MINUS expr .) ]
  ! DIVIDE          [ reduce using rule 51 (expr -> expr MINUS expr .) ]
  ! MOD             [ reduce using rule 51 (expr -> expr MINUS expr .) ]
  ! PLUS            [ shift and go to state 100 ]
  ! MINUS           [ shift and go to state 101 ]
  ! LT              [ shift and go to state 105 ]
  ! GT              [ shift and go to state 106 ]
  ! LE              [ shift and go to state 107 ]
  ! GE              [ shift and go to state 108 ]
  ! EQ              [ shift and go to state 109 ]
  ! NE              [ shift and go to state 110 ]
  ! AND             [ shift and go to state 111 ]
  ! OR              [ shift and go to state 112 ]


state 126

    (52) expr -> expr TIMES expr .
    (50) expr -> expr . PLUS expr
    (51) expr -> expr . MINUS expr
    (52) expr -> expr . TIMES expr
    (53) expr -> expr . DIVIDE expr
    (54) expr -> expr . MOD expr
    (55) expr -> expr . LT expr
    (56) expr -> expr . GT expr
    (57) expr -> expr . LE expr
    (58) expr -> expr . GE expr
    (59) expr -> expr . EQ expr
    (60) expr -> expr . NE expr
    (61) expr -> expr . AND expr
    (62) expr -> expr . OR expr

    PLUS            reduce using rule 52 (expr -> expr TIMES expr .)
    MINUS           reduce using rule 52 (expr -> expr TIMES expr .)
    TIMES           reduce using rule 52 (expr -> expr TIMES expr .)
    DIVIDE          reduce using rule 52 (expr -> expr TIMES expr .)
    MOD             reduce using rule 52 (expr -> expr TIMES expr .)
    LT              reduce using rule 52 (expr -> expr TIMES expr .)
    GT              reduce using rule 52 (expr -> expr TIMES expr .)
    LE              reduce using rule 52 (expr -> expr TIMES expr .)
    GE              reduce using rule 52 (expr -> expr TIMES expr .)
    EQ              reduce using rule 52 (expr -> expr TIMES expr .)
    NE              reduce using rule 52 (expr -> expr TIMES expr .)
    AND             reduce using rule 52 (expr -> expr TIMES expr .)
    OR              reduce using rule 52 (expr -> expr TIMES expr .)
    SEMI            reduce using rule 52 (expr -> expr TIMES expr .)
    RPAREN          reduce using rule 52 (expr -> expr TIMES expr .)
    COMMA           reduce using rule 52 (expr -> expr TIMES expr .)
    RBRACKET        reduce using rule 52 (expr -> expr TIMES expr .)

  ! PLUS            [ shift and go to state 100 ]
  ! MINUS           [ shift and go to state 101 ]
  ! TIMES           [ shift and go to state 102 ]
  ! DIVIDE          [ shift and go to state 103 ]
  ! MOD             [ shift and go to state 104 ]
  ! LT              [ shift and go to state 105 ]
  ! GT              [ shift and go to state 106 ]
  ! LE              [ shift and go to state 107 ]
  ! GE              [ shift and go to state 108 ]
  ! EQ              [ shift and go to state 109 ]
  ! NE              [ shift and go to state 110 ]
  ! AND             [ shift and go to state 111 ]
  ! OR              [ shift and go to state 112 ]


state 127

    (53) expr -> expr DIVIDE expr .
    (50) expr -> expr . PLUS expr
    (51) expr -> expr . MINUS expr
    (52) expr -> expr . TIMES expr
    (53) expr -> expr . DIVIDE expr
    (54) expr -> expr . MOD expr
    (55) expr -> expr . LT expr
    (56) expr -> expr . GT expr
    (57) expr -> expr . LE expr
    (58) expr -> expr . GE expr
    (59) expr -> expr . EQ expr
    (60) expr -> expr . NE expr
    (61) expr -> expr . AND expr
    (62) expr -> expr . OR expr

    PLUS            reduce using rule 53 (expr -> expr DIVIDE expr .)
    MINUS           reduce using rule 53 (expr -> expr DIVIDE expr .)
    TIMES           reduce using rule 53 (expr -> expr DIVIDE expr .)
    DIVIDE          reduce using rule 53 (expr -> expr DIVIDE expr .)
    MOD             reduce using rule 53 (expr -> expr DIVIDE expr .)
    LT              reduce using rule 53 (expr -> expr DIVIDE expr .)
    GT              reduce using rule 53 (expr -> expr DIVIDE expr .)
    LE              reduce using rule 53 (expr -> expr DIVIDE expr .)
    GE              reduce using rule 53 (expr -> expr DIVIDE expr .)
    EQ              reduce using rule 53 (expr -> expr DIVIDE expr .)
    NE              reduce using rule 53 (expr -> expr DIVIDE expr .)
    AND             reduce using rule 53 (expr -> expr DIVIDE expr .)
    OR              reduce using rule 53 (expr -> expr DIVIDE expr .)
    SEMI            reduce using rule 53 (expr -> expr DIVIDE expr .)
    RPAREN          reduce using rule 53 (expr -> expr DIVIDE expr .)
    COMMA           reduce using rule 53 (expr -> expr DIVIDE expr .)
    RBRACKET        reduce using rule 53 (expr -> expr DIVIDE expr .)

  ! PLUS            [ shift and go to state 100 ]
  ! MINUS           [ shift and go to state 101 ]
  ! TIMES           [ shift and go to state 102 ]
  ! DIVIDE          [ shift and go to state 103 ]
  ! MOD             [ shift and go to state 104 ]
  ! LT              [ shift and go to state 105 ]
  ! GT              [ shift and go to state 106 ]
  ! LE              [ shift and go to state 107 ]
  ! GE              [ shift and go to state 108 ]
  ! EQ              [ shift and go to state 109 ]
  ! NE              [ shift and go to state 110 ]
  ! AND             [ shift and go to state 111 ]
  ! OR              [ shift and go to state 112 ]


state 128

    (54) expr -> expr MOD expr .
    (50) expr -> expr . PLUS expr
    (51) expr -> expr . MINUS expr
    (52) expr -> expr . TIMES expr
    (53) expr -> expr . DIVIDE expr
    (54) expr -> expr . MOD expr
    (55) expr -> expr . LT expr
    (56) expr -> expr . GT expr
    (57) expr -> expr . LE expr
    (58) expr -> expr . GE expr
    (59) expr -> expr . EQ expr
    (60) expr -> expr . NE expr
    (61) expr -> expr . AND expr
    (62) expr -> expr . OR expr

    PLUS            reduce using rule 54 (expr -> expr MOD expr .)
    MINUS           reduce using rule 54 (expr -> expr MOD expr .)
    TIMES           reduce using rule 54 (expr -> expr MOD expr .)
    DIVIDE          reduce using rule 54 (expr -> expr MOD expr .)
    MOD             reduce using rule 54 (expr -> expr MOD expr .)
    LT              reduce using rule 54 (expr -> expr MOD expr .)
    GT              reduce using rule 54 (expr -> expr MOD expr .)
    LE              reduce using rule 54 (expr -> expr MOD expr .)
    GE              reduce using rule 54 (expr -> expr MOD expr .)
    EQ              reduce using rule 54 (expr -> expr MOD expr .)
    NE              reduce using rule 54 (expr -> expr MOD expr .)
    AND             reduce using rule 54 (expr -> expr MOD expr .)
    OR              reduce using rule 54 (expr -> expr MOD expr .)
    SEMI            reduce using rule 54 (expr -> expr MOD expr .)
    RPAREN          reduce using rule 54 (expr -> expr MOD expr .)
    COMMA           reduce using rule 54 (expr -> expr MOD expr .)
    RBRACKET        reduce using rule 54 (expr -> expr MOD expr .)

  ! PLUS            [ shift and go to state 100 ]
  ! MINUS           [ shift and go to state 101 ]
  ! TIMES           [ shift and go to state 102 ]
  ! DIVIDE          [ shift and go to state 103 ]
  ! MOD             [ shift and go to state 104 ]
  ! LT              [ shift and go to state 105 ]
  ! GT              [ shift and go to state 106 ]
  ! LE              [ shift and go to state 107 ]
  ! GE              [ shift and go to state 108 ]
  ! EQ              [ shift and go to state 109 ]
  ! NE              [ shift and go to state 110 ]
  ! AND             [ shift and go to state 111 ]
  ! OR              [ shift and go to state 112 ]


state 129

    (55) expr -> expr LT expr .
    (50) expr -> expr . PLUS expr
    (51) expr -> expr . MINUS expr
    (52) expr -> expr . TIMES expr
    (53) expr -> expr . DIVIDE expr
    (54) expr -> expr . MOD expr
    (55) expr -> expr . LT expr
    (56) expr -> expr . GT expr
    (57) expr -> expr . LE expr
    (58) expr -> expr . GE expr
    (59) expr -> expr . EQ expr
    (60) expr -> expr . NE expr
    (61) expr -> expr . AND expr
    (62) expr -> expr . OR expr

    LT              reduce using rule 55 (expr -> expr LT expr .)
    GT              reduce using rule 55 (expr -> expr LT expr .)
    LE              reduce using rule 55 (expr -> expr LT expr .)
    GE              reduce using rule 55 (expr -> expr LT expr .)
    EQ              reduce using rule 55 (expr -> expr LT expr .)
    NE              reduce using rule 55 (expr -> expr LT expr .)
    AND             reduce using rule 55 (expr -> expr LT expr .)
    OR              reduce using rule 55 (expr -> expr LT expr .)
    SEMI            reduce using rule 55 (expr -> expr LT expr .)
    RPAREN          reduce using rule 55 (expr -> expr LT expr .)
    COMMA           reduce using rule 55 (expr -> expr LT expr .)
    RBRACKET        reduce using rule 55 (expr -> expr LT expr .)
    PLUS            shift and go to state 100
    MINUS           shift and go to state 101
    TIMES           shift and go to state 102
    DIVIDE          shift and go to state 103
    MOD             shift and go to state 104

  ! PLUS            [ reduce using rule 55 (expr -> expr LT expr .) ]
  ! MINUS           [ reduce using rule 55 (expr -> expr LT expr .) ]
  ! TIMES           [ reduce using rule 55 (expr -> expr LT expr .) ]
  ! DIVIDE          [ reduce using rule 55 (expr -> expr LT expr .) ]
  ! MOD             [ reduce using rule 55 (expr -> expr LT expr .) ]
  ! LT              [ shift and go to state 105 ]
  ! GT              [ shift and go to state 106 ]
  ! LE              [ shift and go to state 107 ]
  ! GE              [ shift and go to state 108 ]
  ! EQ              [ shift and go to state 109 ]
  ! NE              [ shift and go to state 110 ]
  ! AND             [ shift and go to state 111 ]
  ! OR              [ shift and go to state 112 ]


state 130

    (56) expr -> expr GT expr .
    (50) expr -> expr . PLUS expr
    (51) expr -> expr . MINUS expr
    (52) expr -> expr . TIMES expr
    (53) expr -> expr . DIVIDE expr
    (54) expr -> expr . MOD expr
    (55) expr -> expr . LT expr
    (56) expr -> expr . GT expr
    (57) expr -> expr . LE expr
    (58) expr -> expr . GE expr
    (59) expr -> expr . EQ expr
    (60) expr -> expr . NE expr
    (61) expr -> expr . AND expr
    (62) expr -> expr . OR expr

    LT              reduce using rule 56 (expr -> expr GT expr .)
    GT              reduce using rule 56 (expr -> expr GT expr .)
    LE              reduce using rule 56 (expr -> expr GT expr .)
    GE              reduce using rule 56 (expr -> expr GT expr .)
    EQ              reduce using rule 56 (expr -> expr GT expr .)
    NE              reduce using rule 56 (expr -> expr GT expr .)
    AND             reduce using rule 56 (expr -> expr GT expr .)
    OR              reduce using rule 56 (expr -> expr GT expr .)
    SEMI            reduce using rule 56 (expr -> expr GT expr .)
    RPAREN          reduce using rule 56 (expr -> expr GT expr .)
    COMMA           reduce using rule 56 (expr -> expr GT expr .)
    RBRACKET        reduce using rule 56 (expr -> expr GT expr .)
    PLUS            shift and go to state 100
    MINUS           shift and go to state 101
    TIMES           shift and go to state 102
    DIVIDE          shift and go to state 103
    MOD             shift and go to state 104

  ! PLUS            [ reduce using rule 56 (expr -> expr GT expr .) ]
  ! MINUS           [ reduce using rule 56 (expr -> expr GT expr .) ]
  ! TIMES           [ reduce using rule 56 (expr -> expr GT expr .) ]
  ! DIVIDE          [ reduce using rule 56 (expr -> expr GT expr .) ]
  ! MOD             [ reduce using rule 56 (expr -> expr GT expr .) ]
  ! LT              [ shift and go to state 105 ]
  ! GT              [ shift and go to state 106 ]
  ! LE              [ shift and go to state 107 ]
  ! GE              [ shift and go to state 108 ]
  ! EQ              [ shift and go to state 109 ]
  ! NE              [ shift and go to state 110 ]
  ! AND             [ shift and go to state 111 ]
  ! OR              [ shift and go to state 112 ]


state 131

    (57) expr -> expr LE expr .
    (50) expr -> expr . PLUS expr
    (51) expr -> expr . MINUS expr
    (52) expr -> expr . TIMES expr
    (53) expr -> expr . DIVIDE expr
    (54) expr -> expr . MOD expr
    (55) expr -> expr . LT expr
    (56) expr -> expr . GT expr
    (57) expr -> expr . LE expr
    (58) expr -> expr . GE expr
    (59) expr -> expr . EQ expr
    (60) expr -> expr . NE expr
    (61) expr -> expr . AND expr
    (62) expr -> expr . OR expr

    LT              reduce using rule 57 (expr -> expr LE expr .)
    GT              reduce using rule 57 (expr -> expr LE expr .)
    LE              reduce using rule 57 (expr -> expr LE expr .)
    GE              reduce using rule 57 (expr -> expr LE expr .)
    EQ              reduce using rule 57 (expr -> expr LE expr .)
    NE              reduce using rule 57 (expr -> expr LE expr .)
    AND             reduce using rule 57 (expr -> expr LE expr .)
    OR              reduce using rule 57 (expr -> expr LE expr .)
    SEMI            reduce using rule 57 (expr -> expr LE expr .)
    RPAREN          reduce using rule 57 (expr -> expr LE expr .)
    COMMA           reduce using rule 57 (expr -> expr LE expr .)
    RBRACKET        reduce using rule 57 (expr -> expr LE expr .)
    PLUS            shift and go to state 100
    MINUS           shift and go to state 101
    TIMES           shift and go to state 102
    DIVIDE          shift and go to state 103
    MOD             shift and go to state 104

  ! PLUS            [ reduce using rule 57 (expr -> expr LE expr .) ]
  ! MINUS           [ reduce using rule 57 (expr -> expr LE expr .) ]
  ! TIMES           [ reduce using rule 57 (expr -> expr LE expr .) ]
  ! DIVIDE          [ reduce using rule 57 (expr -> expr LE expr .) ]
  ! MOD             [ reduce using rule 57 (expr -> expr LE expr .) ]
  ! LT              [ shift and go to state 105 ]
  ! GT              [ shift and go to state 106 ]
  ! LE              [ shift and go to state 107 ]
  ! GE              [ shift and go to state 108 ]
  ! EQ              [ shift and go to state 109 ]
  ! NE              [ shift and go to state 110 ]
  ! AND             [ shift and go to state 111 ]
  ! OR              [ shift and go to state 112 ]


state 132

    (58) expr -> expr GE expr .
    (50) expr -> expr . PLUS expr
    (51) expr -> expr . MINUS expr
    (52) expr -> expr . TIMES expr
    (53) expr -> expr . DIVIDE expr
    (54) expr -> expr . MOD expr
    (55) expr -> expr . LT expr
    (56) expr -> expr . GT expr
    (57) expr -> expr . LE expr
    (58) expr -> expr . GE expr
    (59) expr -> expr . EQ expr
    (60) expr -> expr . NE expr
    (61) expr -> expr . AND expr
    (62) expr -> expr . OR expr

    LT              reduce using rule 58 (expr -> expr GE expr .)
    GT              reduce using rule 58 (expr -> expr GE expr .)
    LE              reduce using rule 58 (expr -> expr GE expr .)
    GE              reduce using rule 58 (expr -> expr GE expr .)
    EQ              reduce using rule 58 (expr -> expr GE expr .)
    NE              reduce using rule 58 (expr -> expr GE expr .)
    AND             reduce using rule 58 (expr -> expr GE expr .)
    OR              reduce using rule 58 (expr -> expr GE expr .)
    SEMI            reduce using rule 58 (expr -> expr GE expr .)
    RPAREN          reduce using rule 58 (expr -> expr GE expr .)
    COMMA           reduce using rule 58 (expr -> expr GE expr .)
    RBRACKET        reduce using rule 58 (expr -> expr GE expr .)
    PLUS            shift and go to state 100
    MINUS           shift and go to state 101
    TIMES           shift and go to state 102
    DIVIDE          shift and go to state 103
    MOD             shift and go to state 104

  ! PLUS            [ reduce using rule 58 (expr -> expr GE expr .) ]
  ! MINUS           [ reduce using rule 58 (expr -> expr GE expr .) ]
  ! TIMES           [ reduce using rule 58 (expr -> expr GE expr .) ]
  ! DIVIDE          [ reduce using rule 58 (expr -> expr GE expr .) ]
  ! MOD             [ reduce using rule 58 (expr -> expr GE expr .) ]
  ! LT              [ shift and go to state 105 ]
  ! GT              [ shift and go to state 106 ]
  ! LE              [ shift and go to state 107 ]
  ! GE              [ shift and go to state 108 ]
  ! EQ              [ shift and go to state 109 ]
  ! NE              [ shift and go to state 110 ]
  ! AND             [ shift and go to state 111 ]
  ! OR              [ shift and go to state 112 ]


state 133

    (59) expr -> expr EQ expr .
    (50) expr -> expr . PLUS expr
    (51) expr -> expr . MINUS expr
    (52) expr -> expr . TIMES expr
    (53) expr -> expr . DIVIDE expr
    (54) expr -> expr . MOD expr
    (55) expr -> expr . LT expr
    (56) expr -> expr . GT expr
    (57) expr -> expr . LE expr
    (58) expr -> expr . GE expr
    (59) expr -> expr . EQ expr
    (60) expr -> expr . NE expr
    (61) expr -> expr . AND expr
    (62) expr -> expr . OR expr

    EQ              reduce using rule 59 (expr -> expr EQ expr .)
    NE              reduce using rule 59 (expr -> expr EQ expr .)
    AND             reduce using rule 59 (expr -> expr EQ expr .)
    OR              reduce using rule 59 (expr -> expr EQ expr .)
    SEMI            reduce using rule 59 (expr -> expr EQ expr .)
    RPAREN          reduce using rule 59 (expr -> expr EQ expr .)
    COMMA           reduce using rule 59 (expr -> expr EQ expr .)
    RBRACKET        reduce using rule 59 (expr -> expr EQ expr .)
    PLUS            shift and go to state 100
    MINUS           shift and go to state 101
    TIMES           shift and go to state 102
    DIVIDE          shift and go to state 103
    MOD             shift and go to state 104
    LT              shift and go to state 105
    GT              shift and go to state 106
    LE              shift and go to state 107
    GE              shift and go to state 108

  ! PLUS            [ reduce using rule 59 (expr -> expr EQ expr .) ]
  ! MINUS           [ reduce using rule 59 (expr -> expr EQ expr .) ]
  ! TIMES           [ reduce using rule 59 (expr -> expr EQ expr .) ]
  ! DIVIDE          [ reduce using rule 59 (expr -> expr EQ expr .) ]
  ! MOD             [ reduce using rule 59 (expr -> expr EQ expr .) ]
  ! LT              [ reduce using rule 59 (expr -> expr EQ expr .) ]
  ! GT              [ reduce using rule 59 (expr -> expr EQ expr .) ]
  ! LE              [ reduce using rule 59 (expr -> expr EQ expr .) ]
  ! GE              [ reduce using rule 59 (expr -> expr EQ expr .) ]
  ! EQ              [ shift and go to state 109 ]
  ! NE              [ shift and go to state 110 ]
  ! AND             [ shift and go to state 111 ]
  ! OR              [ shift and go to state 112 ]


state 134

    (60) expr -> expr NE expr .
    (50) expr -> expr . PLUS expr
    (51) expr -> expr . MINUS expr
    (52) expr -> expr . TIMES expr
    (53) expr -> expr . DIVIDE expr
    (54) expr -> expr . MOD expr
    (55) expr -> expr . LT expr
    (56) expr -> expr . GT expr
    (57) expr -> expr . LE expr
    (58) expr -> expr . GE expr
    (59) expr -> expr . EQ expr
    (60) expr -> expr . NE expr
    (61) expr -> expr . AND expr
    (62) expr -> expr . OR expr

    EQ              reduce using rule 60 (expr -> expr NE expr .)
    NE              reduce using rule 60 (expr -> expr NE expr .)
    AND             reduce using rule 60 (expr -> expr NE expr .)
    OR              reduce using rule 60 (expr -> expr NE expr .)
    SEMI            reduce using rule 60 (expr -> expr NE expr .)
    RPAREN          reduce using rule 60 (expr -> expr NE expr .)
    COMMA           reduce using rule 60 (expr -> expr NE expr .)
    RBRACKET        reduce using rule 60 (expr -> expr NE expr .)
    PLUS            shift and go to state 100
    MINUS           shift and go to state 101
    TIMES           shift and go to state 102
    DIVIDE          shift and go to state 103
    MOD             shift and go to state 104
    LT              shift and go to state 105
    GT              shift and go to state 106
    LE              shift and go to state 107
    GE              shift and go to state 108

  ! PLUS            [ reduce using rule 60 (expr -> expr NE expr .) ]
  ! MINUS           [ reduce using rule 60 (expr -> expr NE expr .) ]
  ! TIMES           [ reduce using rule 60 (expr -> expr NE expr .) ]
  ! DIVIDE          [ reduce using rule 60 (expr -> expr NE expr .) ]
  ! MOD             [ reduce using rule 60 (expr -> expr NE expr .) ]
  ! LT              [ reduce using rule 60 (expr -> expr NE expr .) ]
  ! GT              [ reduce using rule 60 (expr -> expr NE expr .) ]
  ! LE              [ reduce using rule 60 (expr -> expr NE expr .) ]
  ! GE              [ reduce using rule 60 (expr -> expr NE expr .) ]
  ! EQ              [ shift and go to state 109 ]
  ! NE              [ shift and go to state 110 ]
  ! AND             [ shift and go to state 111 ]
  ! OR              [ shift and go to state 112 ]


state 135

    (61) expr -> expr AND expr .
    (50) expr -> expr . PLUS expr
    (51) expr -> expr . MINUS expr
    (52) expr -> expr . TIMES expr
    (53) expr -> expr . DIVIDE expr
    (54) expr -> expr . MOD expr
    (55) expr -> expr . LT expr
    (56) expr -> expr . GT expr
    (57) expr -> expr . LE expr
    (58) expr -> expr . GE expr
    (59) expr -> expr . EQ expr
    (60) expr -> expr . NE expr
    (61) expr -> expr . AND expr
    (62) expr -> expr . OR expr

    AND             reduce using rule 61 (expr -> expr AND expr .)
    OR              reduce using rule 61 (expr -> expr AND expr .)
    SEMI            reduce using rule 61 (expr -> expr AND expr .)
    RPAREN          reduce using rule 61 (expr -> expr AND expr .)
    COMMA           reduce using rule 61 (expr -> expr AND expr .)
    RBRACKET        reduce using rule 61 (expr -> expr AND expr .)
    PLUS            shift and go to state 100
    MINUS           shift and go to state 101
    TIMES           shift and go to state 102
    DIVIDE          shift and go to state 103
    MOD             shift and go to state 104
    LT              shift and go to state 105
    GT              shift and go to state 106
    LE              shift and go to state 107
    GE              shift and go to state 108
    EQ              shift and go to state 109
    NE              shift and go to state 110

  ! PLUS            [ reduce using rule 61 (expr -> expr AND expr .) ]
  ! MINUS           [ reduce using rule 61 (expr -> expr AND expr .) ]
  ! TIMES           [ reduce using rule 61 (expr -> expr AND expr .) ]
  ! DIVIDE          [ reduce using rule 61 (expr -> expr AND expr .) ]
  ! MOD             [ reduce using rule 61 (expr -> expr AND expr .) ]
  ! LT              [ reduce using rule 61 (expr -> expr AND expr .) ]
  ! GT              [ reduce using rule 61 (expr -> expr AND expr .) ]
  ! LE              [ reduce using rule 61 (expr -> expr AND expr .) ]
  ! GE              [ reduce using rule 61 (expr -> expr AND expr .) ]
  ! EQ              [ reduce using rule 61 (expr -> expr AND expr .) ]
  ! NE              [ reduce using rule 61 (expr -> expr AND expr .) ]
  ! AND             [ shift and go to state 111 ]
  ! OR              [ shift and go to state 112 ]


state 136

    (62) expr -> expr OR expr .
    (50) expr -> expr . PLUS expr
    (51) expr -> expr . MINUS expr
    (52) expr -> expr . TIMES expr
    (53) expr -> expr . DIVIDE expr
    (54) expr -> expr . MOD expr
    (55) expr -> expr . LT expr
    (56) expr -> expr . GT expr
    (57) expr -> expr . LE expr
    (58) expr -> expr . GE expr
    (59) expr -> expr . EQ expr
    (60) expr -> expr . NE expr
    (61) expr -> expr . AND expr
    (62) expr -> expr . OR expr

    OR              reduce using rule 62 (expr -> expr OR expr .)
    SEMI            reduce using rule 62 (expr -> expr OR expr .)
    RPAREN          reduce using rule 62 (expr -> expr OR expr .)
    COMMA           reduce using rule 62 (expr -> expr OR expr .)
    RBRACKET        reduce using rule 62 (expr -> expr OR expr .)
    PLUS            shift and go to state 100
    MINUS           shift and go to state 101
    TIMES           shift and go to state 102
    DIVIDE          shift and go to state 103
    MOD             shift and go to state 104
    LT              shift and go to state 105
    GT              shift and go to state 106
    LE              shift and go to state 107
    GE              shift and go to state 108
    EQ              shift and go to state 109
    NE              shift and go to state 110
    AND             shift and go to state 111

  ! PLUS            [ reduce using rule 62 (expr -> expr OR expr .) ]
  ! MINUS           [ reduce using rule 62 (expr -> expr OR expr .) ]
  ! TIMES           [ reduce using rule 62 (expr -> expr OR expr .) ]
  ! DIVIDE          [ reduce using rule 62 (expr -> expr OR expr .) ]
  ! MOD             [ reduce using rule 62 (expr -> expr OR expr .) ]
  ! LT              [ reduce using rule 62 (expr -> expr OR expr .) ]
  ! GT              [ reduce using rule 62 (expr -> expr OR expr .) ]
  ! LE              [ reduce using rule 62 (expr -> expr OR expr .) ]
  ! GE              [ reduce using rule 62 (expr -> expr OR expr .) ]
  ! EQ              [ reduce using rule 62 (expr -> expr OR expr .) ]
  ! NE              [ reduce using rule 62 (expr -> expr OR expr .) ]
  ! AND             [ reduce using rule 62 (expr -> expr OR expr .) ]
  ! OR              [ shift and go to state 112 ]


state 137

    (65) expr -> LPAREN expr RPAREN .

    PLUS            reduce using rule 65 (expr -> LPAREN expr RPAREN .)
    MINUS           reduce using rule 65 (expr -> LPAREN expr RPAREN .)
    TIMES           reduce using rule 65 (expr -> LPAREN expr RPAREN .)
    DIVIDE          reduce using rule 65 (expr -> LPAREN expr RPAREN .)
    MOD             reduce using rule 65 (expr -> LPAREN expr RPAREN .)
    LT              reduce using rule 65 (expr -> LPAREN expr RPAREN .)
    GT              reduce using rule 65 (expr -> LPAREN expr RPAREN .)
    LE              reduce using rule 65 (expr -> LPAREN expr RPAREN .)
    GE              reduce using rule 65 (expr -> LPAREN expr RPAREN .)
    EQ              reduce using rule 65 (expr -> LPAREN expr RPAREN .)
    NE              reduce using rule 65 (expr -> LPAREN expr RPAREN .)
    AND             reduce using rule 65 (expr -> LPAREN expr RPAREN .)
    OR              reduce using rule 65 (expr -> LPAREN expr RPAREN .)
    SEMI            reduce using rule 65 (expr -> LPAREN expr RPAREN .)
    RPAREN          reduce using rule 65 (expr -> LPAREN expr RPAREN .)
    COMMA           reduce using rule 65 (expr -> LPAREN expr RPAREN .)
    RBRACKET        reduce using rule 65 (expr -> LPAREN expr RPAREN .)


state 138

    (72) arg_list -> arg_list COMMA expr .
    (50) expr -> expr . PLUS expr
    (51) expr -> expr . MINUS expr
    (52) expr -> expr . TIMES expr
    (53) expr -> expr . DIVIDE expr
    (54) expr -> expr . MOD expr
    (55) expr -> expr . LT expr
    (56) expr -> expr . GT expr
    (57) expr -> expr . LE expr
    (58) expr -> expr . GE expr
    (59) expr -> expr . EQ expr
    (60) expr -> expr . NE expr
    (61) expr -> expr . AND expr
    (62) expr -> expr . OR expr

    COMMA           reduce using rule 72 (arg_list -> arg_list COMMA expr .)
    RPAREN          reduce using rule 72 (arg_list -> arg_list COMMA expr .)
    PLUS            shift and go to state 100
    MINUS           shift and go to state 101
    TIMES           shift and go to state 102
    DIVIDE          shift and go to state 103
    MOD             shift and go to state 104
    LT              shift and go to state 105
    GT              shift and go to state 106
    LE              shift and go to state 107
    GE              shift and go to state 108
    EQ              shift and go to state 109
    NE              shift and go to state 110
    AND             shift and go to state 111
    OR              shift and go to state 112


state 139

    (36) if_stmt -> IF LPAREN expr RPAREN block . elif_part else_part_opt
    (37) elif_part -> . ELIF LPAREN expr RPAREN block elif_part
    (38) elif_part -> . empty
    (80) empty -> .

    ELIF            shift and go to state 143
    ELSE            reduce using rule 80 (empty -> .)
    RBRACE          reduce using rule 80 (empty -> .)
    ID              reduce using rule 80 (empty -> .)
    IF              reduce using rule 80 (empty -> .)
    WHILE           reduce using rule 80 (empty -> .)
    FOR             reduce using rule 80 (empty -> .)
    PRINT           reduce using rule 80 (empty -> .)
    INPUT           reduce using rule 80 (empty -> .)
    RETURN          reduce using rule 80 (empty -> .)
    BREAK           reduce using rule 80 (empty -> .)
    CONTINUE        reduce using rule 80 (empty -> .)
    LBRACE          reduce using rule 80 (empty -> .)
    INT             reduce using rule 80 (empty -> .)
    FLOAT           reduce using rule 80 (empty -> .)
    BOOL            reduce using rule 80 (empty -> .)
    CHAR            reduce using rule 80 (empty -> .)
    STRING          reduce using rule 80 (empty -> .)

    elif_part                      shift and go to state 142
    empty                          shift and go to state 144

state 140

    (41) while_stmt -> WHILE LPAREN expr RPAREN block .

    RBRACE          reduce using rule 41 (while_stmt -> WHILE LPAREN expr RPAREN block .)
    ID              reduce using rule 41 (while_stmt -> WHILE LPAREN expr RPAREN block .)
    IF              reduce using rule 41 (while_stmt -> WHILE LPAREN expr RPAREN block .)
    WHILE           reduce using rule 41 (while_stmt -> WHILE LPAREN expr RPAREN block .)
    FOR             reduce using rule 41 (while_stmt -> WHILE LPAREN expr RPAREN block .)
    PRINT           reduce using rule 41 (while_stmt -> WHILE LPAREN expr RPAREN block .)
    INPUT           reduce using rule 41 (while_stmt -> WHILE LPAREN expr RPAREN block .)
    RETURN          reduce using rule 41 (while_stmt -> WHILE LPAREN expr RPAREN block .)
    BREAK           reduce using rule 41 (while_stmt -> WHILE LPAREN expr RPAREN block .)
    CONTINUE        reduce using rule 41 (while_stmt -> WHILE LPAREN expr RPAREN block .)
    LBRACE          reduce using rule 41 (while_stmt -> WHILE LPAREN expr RPAREN block .)
    INT             reduce using rule 41 (while_stmt -> WHILE LPAREN expr RPAREN block .)
    FLOAT           reduce using rule 41 (while_stmt -> WHILE LPAREN expr RPAREN block .)
    BOOL            reduce using rule 41 (while_stmt -> WHILE LPAREN expr RPAREN block .)
    CHAR            reduce using rule 41 (while_stmt -> WHILE LPAREN expr RPAREN block .)
    STRING          reduce using rule 41 (while_stmt -> WHILE LPAREN expr RPAREN block .)


state 141

    (42) for_stmt -> FOR LPAREN assignment SEMI expr . SEMI assignment RPAREN block
    (50) expr -> expr . PLUS expr
    (51) expr -> expr . MINUS expr
    (52) expr -> expr . TIMES expr
    (53) expr -> expr . DIVIDE expr
    (54) expr -> expr . MOD expr
    (55) expr -> expr . LT expr
    (56) expr -> expr . GT expr
    (57) expr -> expr . LE expr
    (58) expr -> expr . GE expr
    (59) expr -> expr . EQ expr
    (60) expr -> expr . NE expr
    (61) expr -> expr . AND expr
    (62) expr -> expr . OR expr

    SEMI            shift and go to state 145
    PLUS            shift and go to state 100
    MINUS           shift and go to state 101
    TIMES           shift and go to state 102
    DIVIDE          shift and go to state 103
    MOD             shift and go to state 104
    LT              shift and go to state 105
    GT              shift and go to state 106
    LE              shift and go to state 107
    GE              shift and go to state 108
    EQ              shift and go to state 109
    NE              shift and go to state 110
    AND             shift and go to state 111
    OR              shift and go to state 112


state 142

    (36) if_stmt -> IF LPAREN expr RPAREN block elif_part . else_part_opt
    (39) else_part_opt -> . ELSE block
    (40) else_part_opt -> . empty
    (80) empty -> .

    ELSE            shift and go to state 147
    RBRACE          reduce using rule 80 (empty -> .)
    ID              reduce using rule 80 (empty -> .)
    IF              reduce using rule 80 (empty -> .)
    WHILE           reduce using rule 80 (empty -> .)
    FOR             reduce using rule 80 (empty -> .)
    PRINT           reduce using rule 80 (empty -> .)
    INPUT           reduce using rule 80 (empty -> .)
    RETURN          reduce using rule 80 (empty -> .)
    BREAK           reduce using rule 80 (empty -> .)
    CONTINUE        reduce using rule 80 (empty -> .)
    LBRACE          reduce using rule 80 (empty -> .)
    INT             reduce using rule 80 (empty -> .)
    FLOAT           reduce using rule 80 (empty -> .)
    BOOL            reduce using rule 80 (empty -> .)
    CHAR            reduce using rule 80 (empty -> .)
    STRING          reduce using rule 80 (empty -> .)

    else_part_opt                  shift and go to state 146
    empty                          shift and go to state 148

state 143

    (37) elif_part -> ELIF . LPAREN expr RPAREN block elif_part

    LPAREN          shift and go to state 149


state 144

    (38) elif_part -> empty .

    ELSE            reduce using rule 38 (elif_part -> empty .)
    RBRACE          reduce using rule 38 (elif_part -> empty .)
    ID              reduce using rule 38 (elif_part -> empty .)
    IF              reduce using rule 38 (elif_part -> empty .)
    WHILE           reduce using rule 38 (elif_part -> empty .)
    FOR             reduce using rule 38 (elif_part -> empty .)
    PRINT           reduce using rule 38 (elif_part -> empty .)
    INPUT           reduce using rule 38 (elif_part -> empty .)
    RETURN          reduce using rule 38 (elif_part -> empty .)
    BREAK           reduce using rule 38 (elif_part -> empty .)
    CONTINUE        reduce using rule 38 (elif_part -> empty .)
    LBRACE          reduce using rule 38 (elif_part -> empty .)
    INT             reduce using rule 38 (elif_part -> empty .)
    FLOAT           reduce using rule 38 (elif_part -> empty .)
    BOOL            reduce using rule 38 (elif_part -> empty .)
    CHAR            reduce using rule 38 (elif_part -> empty .)
    STRING          reduce using rule 38 (elif_part -> empty .)


state 145

    (42) for_stmt -> FOR LPAREN assignment SEMI expr SEMI . assignment RPAREN block
    (33) assignment -> . location ASSIGN expr
    (34) location -> . ID
    (35) location -> . ID LBRACKET expr RBRACKET

    ID              shift and go to state 97

    assignment                     shift and go to state 150
    location                       shift and go to state 48

state 146

    (36) if_stmt -> IF LPAREN expr RPAREN block elif_part else_part_opt .

    RBRACE          reduce using rule 36 (if_stmt -> IF LPAREN expr RPAREN block elif_part else_part_opt .)
    ID              reduce using rule 36 (if_stmt -> IF LPAREN expr RPAREN block elif_part else_part_opt .)
    IF              reduce using rule 36 (if_stmt -> IF LPAREN expr RPAREN block elif_part else_part_opt .)
    WHILE           reduce using rule 36 (if_stmt -> IF LPAREN expr RPAREN block elif_part else_part_opt .)
    FOR             reduce using rule 36 (if_stmt -> IF LPAREN expr RPAREN block elif_part else_part_opt .)
    PRINT           reduce using rule 36 (if_stmt -> IF LPAREN expr RPAREN block elif_part else_part_opt .)
    INPUT           reduce using rule 36 (if_stmt -> IF LPAREN expr RPAREN block elif_part else_part_opt .)
    RETURN          reduce using rule 36 (if_stmt -> IF LPAREN expr RPAREN block elif_part else_part_opt .)
    BREAK           reduce using rule 36 (if_stmt -> IF LPAREN expr RPAREN block elif_part else_part_opt .)
    CONTINUE        reduce using rule 36 (if_stmt -> IF LPAREN expr RPAREN block elif_part else_part_opt .)
    LBRACE          reduce using rule 36 (if_stmt -> IF LPAREN expr RPAREN block elif_part else_part_opt .)
    INT             reduce using rule 36 (if_stmt -> IF LPAREN expr RPAREN block elif_part else_part_opt .)
    FLOAT           reduce using rule 36 (if_stmt -> IF LPAREN expr RPAREN block elif_part else_part_opt .)
    BOOL            reduce using rule 36 (if_stmt -> IF LPAREN expr RPAREN block elif_part else_part_opt .)
    CHAR            reduce using rule 36 (if_stmt -> IF LPAREN expr RPAREN block elif_part else_part_opt .)
    STRING          reduce using rule 36 (if_stmt -> IF LPAREN expr RPAREN block elif_part else_part_opt .)


state 147

    (39) else_part_opt -> ELSE . block
    (19) block -> . LBRACE statement_list RBRACE

    LBRACE          shift and go to state 31

    block                          shift and go to state 151

state 148

    (40) else_part_opt -> empty .

    RBRACE          reduce using rule 40 (else_part_opt -> empty .)
    ID              reduce using rule 40 (else_part_opt -> empty .)
    IF              reduce using rule 40 (else_part_opt -> empty .)
    WHILE           reduce using rule 40 (else_part_opt -> empty .)
    FOR             reduce using rule 40 (else_part_opt -> empty .)
    PRINT           reduce using rule 40 (else_part_opt -> empty .)
    INPUT           reduce using rule 40 (else_part_opt -> empty .)
    RETURN          reduce using rule 40 (else_part_opt -> empty .)
    BREAK           reduce using rule 40 (else_part_opt -> empty .)
    CONTINUE        reduce using rule 40 (else_part_opt -> empty .)
    LBRACE          reduce using rule 40 (else_part_opt -> empty .)
    INT             reduce using rule 40 (else_part_opt -> empty .)
    FLOAT           reduce using rule 40 (else_part_opt -> empty .)
    BOOL            reduce using rule 40 (else_part_opt -> empty .)
    CHAR            reduce using rule 40 (else_part_opt -> empty .)
    STRING          reduce using rule 40 (else_part_opt -> empty .)


state 149

    (37) elif_part -> ELIF LPAREN . expr RPAREN block elif_part
    (50) expr -> . expr PLUS expr
    (51) expr -> . expr MINUS expr
    (52) expr -> . expr TIMES expr
    (53) expr -> . expr DIVIDE expr
    (54) expr -> . expr MOD expr
    (55) expr -> . expr LT expr
    (56) expr -> . expr GT expr
    (57) expr -> . expr LE expr
    (58) expr -> . expr GE expr
    (59) expr -> . expr EQ expr
    (60) expr -> . expr NE expr
    (61) expr -> . expr AND expr
    (62) expr -> . expr OR expr
    (63) expr -> . MINUS expr
    (64) expr -> . NOT expr
    (65) expr -> . LPAREN expr RPAREN
    (66) expr -> . literal
    (67) expr -> . location
    (68) expr -> . func_call
    (74) literal -> . INT_LITERAL
    (75) literal -> . FLOAT_LITERAL
    (76) literal -> . CHAR_LITERAL
    (77) literal -> . STRING_LITERAL
    (78) literal -> . TRUE
    (79) literal -> . FALSE
    (34) location -> . ID
    (35) location -> . ID LBRACKET expr RBRACKET
    (69) func_call -> . ID LPAREN arg_list_opt RPAREN

    MINUS           shift and go to state 75
    NOT             shift and go to state 76
    LPAREN          shift and go to state 77
    INT_LITERAL     shift and go to state 81
    FLOAT_LITERAL   shift and go to state 82
    CHAR_LITERAL    shift and go to state 83
    STRING_LITERAL  shift and go to state 84
    TRUE            shift and go to state 85
    FALSE           shift and go to state 86
    ID              shift and go to state 87

    expr                           shift and go to state 152
    literal                        shift and go to state 78
    location                       shift and go to state 79
    func_call                      shift and go to state 80

state 150

    (42) for_stmt -> FOR LPAREN assignment SEMI expr SEMI assignment . RPAREN block

    RPAREN          shift and go to state 153


state 151

    (39) else_part_opt -> ELSE block .

    RBRACE          reduce using rule 39 (else_part_opt -> ELSE block .)
    ID              reduce using rule 39 (else_part_opt -> ELSE block .)
    IF              reduce using rule 39 (else_part_opt -> ELSE block .)
    WHILE           reduce using rule 39 (else_part_opt -> ELSE block .)
    FOR             reduce using rule 39 (else_part_opt -> ELSE block .)
    PRINT           reduce using rule 39 (else_part_opt -> ELSE block .)
    INPUT           reduce using rule 39 (else_part_opt -> ELSE block .)
    RETURN          reduce using rule 39 (else_part_opt -> ELSE block .)
    BREAK           reduce using rule 39 (else_part_opt -> ELSE block .)
    CONTINUE        reduce using rule 39 (else_part_opt -> ELSE block .)
    LBRACE          reduce using rule 39 (else_part_opt -> ELSE block .)
    INT             reduce using rule 39 (else_part_opt -> ELSE block .)
    FLOAT           reduce using rule 39 (else_part_opt -> ELSE block .)
    BOOL            reduce using rule 39 (else_part_opt -> ELSE block .)
    CHAR            reduce using rule 39 (else_part_opt -> ELSE block .)
    STRING          reduce using rule 39 (else_part_opt -> ELSE block .)


state 152

    (37) elif_part -> ELIF LPAREN expr . RPAREN block elif_part
    (50) expr -> expr . PLUS expr
    (51) expr -> expr . MINUS expr
    (52) expr -> expr . TIMES expr
    (53) expr -> expr . DIVIDE expr
    (54) expr -> expr . MOD expr
    (55) expr -> expr . LT expr
    (56) expr -> expr . GT expr
    (57) expr -> expr . LE expr
    (58) expr -> expr . GE expr
    (59) expr -> expr . EQ expr
    (60) expr -> expr . NE expr
    (61) expr -> expr . AND expr
    (62) expr -> expr . OR expr

    RPAREN          shift and go to state 154
    PLUS            shift and go to state 100
    MINUS           shift and go to state 101
    TIMES           shift and go to state 102
    DIVIDE          shift and go to state 103
    MOD             shift and go to state 104
    LT              shift and go to state 105
    GT              shift and go to state 106
    LE              shift and go to state 107
    GE              shift and go to state 108
    EQ              shift and go to state 109
    NE              shift and go to state 110
    AND             shift and go to state 111
    OR              shift and go to state 112


state 153

    (42) for_stmt -> FOR LPAREN assignment SEMI expr SEMI assignment RPAREN . block
    (19) block -> . LBRACE statement_list RBRACE

    LBRACE          shift and go to state 31

    block                          shift and go to state 155

state 154

    (37) elif_part -> ELIF LPAREN expr RPAREN . block elif_part
    (19) block -> . LBRACE statement_list RBRACE

    LBRACE          shift and go to state 31

    block                          shift and go to state 156

state 155

    (42) for_stmt -> FOR LPAREN assignment SEMI expr SEMI assignment RPAREN block .

    RBRACE          reduce using rule 42 (for_stmt -> FOR LPAREN assignment SEMI expr SEMI assignment RPAREN block .)
    ID              reduce using rule 42 (for_stmt -> FOR LPAREN assignment SEMI expr SEMI assignment RPAREN block .)
    IF              reduce using rule 42 (for_stmt -> FOR LPAREN assignment SEMI expr SEMI assignment RPAREN block .)
    WHILE           reduce using rule 42 (for_stmt -> FOR LPAREN assignment SEMI expr SEMI assignment RPAREN block .)
    FOR             reduce using rule 42 (for_stmt -> FOR LPAREN assignment SEMI expr SEMI assignment RPAREN block .)
    PRINT           reduce using rule 42 (for_stmt -> FOR LPAREN assignment SEMI expr SEMI assignment RPAREN block .)
    INPUT           reduce using rule 42 (for_stmt -> FOR LPAREN assignment SEMI expr SEMI assignment RPAREN block .)
    RETURN          reduce using rule 42 (for_stmt -> FOR LPAREN assignment SEMI expr SEMI assignment RPAREN block .)
    BREAK           reduce using rule 42 (for_stmt -> FOR LPAREN assignment SEMI expr SEMI assignment RPAREN block .)
    CONTINUE        reduce using rule 42 (for_stmt -> FOR LPAREN assignment SEMI expr SEMI assignment RPAREN block .)
    LBRACE          reduce using rule 42 (for_stmt -> FOR LPAREN assignment SEMI expr SEMI assignment RPAREN block .)
    INT             reduce using rule 42 (for_stmt -> FOR LPAREN assignment SEMI expr SEMI assignment RPAREN block .)
    FLOAT           reduce using rule 42 (for_stmt -> FOR LPAREN assignment SEMI expr SEMI assignment RPAREN block .)
    BOOL            reduce using rule 42 (for_stmt -> FOR LPAREN assignment SEMI expr SEMI assignment RPAREN block .)
    CHAR            reduce using rule 42 (for_stmt -> FOR LPAREN assignment SEMI expr SEMI assignment RPAREN block .)
    STRING          reduce using rule 42 (for_stmt -> FOR LPAREN assignment SEMI expr SEMI assignment RPAREN block .)


state 156

    (37) elif_part -> ELIF LPAREN expr RPAREN block . elif_part
    (37) elif_part -> . ELIF LPAREN expr RPAREN block elif_part
    (38) elif_part -> . empty
    (80) empty -> .

    ELIF            shift and go to state 143
    ELSE            reduce using rule 80 (empty -> .)
    RBRACE          reduce using rule 80 (empty -> .)
    ID              reduce using rule 80 (empty -> .)
    IF              reduce using rule 80 (empty -> .)
    WHILE           reduce using rule 80 (empty -> .)
    FOR             reduce using rule 80 (empty -> .)
    PRINT           reduce using rule 80 (empty -> .)
    INPUT           reduce using rule 80 (empty -> .)
    RETURN          reduce using rule 80 (empty -> .)
    BREAK           reduce using rule 80 (empty -> .)
    CONTINUE        reduce using rule 80 (empty -> .)
    LBRACE          reduce using rule 80 (empty -> .)
    INT             reduce using rule 80 (empty -> .)
    FLOAT           reduce using rule 80 (empty -> .)
    BOOL            reduce using rule 80 (empty -> .)
    CHAR            reduce using rule 80 (empty -> .)
    STRING          reduce using rule 80 (empty -> .)

    elif_part                      shift and go to state 157
    empty                          shift and go to state 144

state 157

    (37) elif_part -> ELIF LPAREN expr RPAREN block elif_part .

    ELSE            reduce using rule 37 (elif_part -> ELIF LPAREN expr RPAREN block elif_part .)
    RBRACE          reduce using rule 37 (elif_part -> ELIF LPAREN expr RPAREN block elif_part .)
    ID              reduce using rule 37 (elif_part -> ELIF LPAREN expr RPAREN block elif_part .)
    IF              reduce using rule 37 (elif_part -> ELIF LPAREN expr RPAREN block elif_part .)
    WHILE           reduce using rule 37 (elif_part -> ELIF LPAREN expr RPAREN block elif_part .)
    FOR             reduce using rule 37 (elif_part -> ELIF LPAREN expr RPAREN block elif_part .)
    PRINT           reduce using rule 37 (elif_part -> ELIF LPAREN expr RPAREN block elif_part .)
    INPUT           reduce using rule 37 (elif_part -> ELIF LPAREN expr RPAREN block elif_part .)
    RETURN          reduce using rule 37 (elif_part -> ELIF LPAREN expr RPAREN block elif_part .)
    BREAK           reduce using rule 37 (elif_part -> ELIF LPAREN expr RPAREN block elif_part .)
    CONTINUE        reduce using rule 37 (elif_part -> ELIF LPAREN expr RPAREN block elif_part .)
    LBRACE          reduce using rule 37 (elif_part -> ELIF LPAREN expr RPAREN block elif_part .)
    INT             reduce using rule 37 (elif_part -> ELIF LPAREN expr RPAREN block elif_part .)
    FLOAT           reduce using rule 37 (elif_part -> ELIF LPAREN expr RPAREN block elif_part .)
    BOOL            reduce using rule 37 (elif_part -> ELIF LPAREN expr RPAREN block elif_part .)
    CHAR            reduce using rule 37 (elif_part -> ELIF LPAREN expr RPAREN block elif_part .)
    STRING          reduce using rule 37 (elif_part -> ELIF LPAREN expr RPAREN block elif_part .)

